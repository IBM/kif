# Copyright (C) 2024-2025 IBM Corp.
# SPDX-License-Identifier: Apache-2.0

from __future__ import annotations

import abc

from ... import itertools
from ...context import Context
from ...model import (
    DatatypeVariable,
    IRI_Variable,
    QuantityVariable,
    StringVariable,
    TimeVariable,
    Variable,
)
from ...typing import cast, Final, Iterator, Sequence
from ..compiler import Compiler
from .builder import SelectQuery
from .options import SPARQL_CompilerOptions as Options


class SPARQL_Compiler(Compiler):
    """Abstract base class for SPARQL compilers."""

    class Query(SelectQuery):
        """The type of queries generated by the SPARQL compiler."""

    __slots__ = (
        '_debug',
        '_omega',
        '_query_stack',
    )

    #: Whether to enable debugging.
    _debug: bool

    #: Maximum number of disjoint queries generate.
    _omega: int

    #: The generated disjoint queries.
    _query_stack: Sequence[SPARQL_Compiler.Query]

    @abc.abstractmethod
    def __init__(
            self,
            debug: bool | None = None,
            omega: int | None = None,
            context: Context | None = None
    ) -> None:
        self._query_stack = [self.Query()]
        self._omega = max(int(omega), 1) if omega is not None else 1
        self._debug = bool(debug or False)

    @property
    def default_options(self) -> Options:
        """The default options of compiler."""
        return self.get_default_options()

    def get_default_options(self, context: Context | None = None) -> Options:
        """Gets the default options of compiler.

        Parameters:
           context: Context.

        Returns:
           Compiler options.
        """
        return self.get_context(context).options.compiler.sparql

    @property
    def debug(self) -> bool:
        """Whether debugging is enabled."""
        return self.get_debug()

    def get_debug(self) -> bool:
        """Gets the debug flag.

        Returns:
           Debug flag.
        """
        return self._debug

    @property
    def omega(self) -> int:
        """The maximum number of disjoint queries to generate."""
        return self.get_omega()

    def get_omega(self) -> int:
        """Gets the maximum number of disjoint queries to generate.

        Returns:
           Maximum number of disjoint queries.
        """
        return self._omega

    @property
    def query_stack(self) -> Sequence[Query]:
        """The compiled query stack."""
        return self.get_query_stack()

    def get_query_stack(self) -> Sequence[Query]:
        """Get the compiled query stack.

        Returns:
           Query stack.
        """
        return self._query_stack

    def push_query(self, query: Query | None = None) -> Query:
        """Pushes query onto query stack.

        If `query` is ``None``, pushes an empty query.

        Returns:
           The pushed query.
        """
        query = query or self.Query()
        cast(list, self._query_stack).append(query)
        return query

    def pop_query(self) -> Query:
        """Pops query from query stack.

        Returns:
           The popped query.
        """
        assert self._query_stack
        return cast(list, self._query_stack).pop()

    @property
    def q(self) -> Query:
        """The current query (top of query stack)."""
        return self.get_query()

    @property
    def query(self) -> Query:
        """The current query (top of query stack)."""
        return self.get_query()

    def get_query(self) -> Query:
        """Gets the current query (top of query stack).

        Returns:
           Query.
        """
        assert self._query_stack
        return self._query_stack[-1]

    @classmethod
    def uri(cls, content: Query.T_URI) -> Query.URI:
        """Alias of :meth:`Query.uri`."""
        return cls.Query.uri(content)

    @classmethod
    def bnode(cls) -> Query.BNode:
        """Alias of :meth:`Query.bnode`."""
        return cls.Query.bnode()

    @classmethod
    def literal(
            cls,
            content: Query.TLiteral,
            language: str | None = None,
            datatype: str | None = None
    ) -> Query.Literal:
        """Alias of :meth:`Query.literal`."""
        return cls.Query.literal(content, language, datatype)

    @classmethod
    def qvar(cls, name: Query.TVariable) -> Query.Variable:
        """Alias of :meth:`Query.var`."""
        return cls.Query.var(name)

    @classmethod
    def qvars(
            cls,
            var: Query.TVariable,
            *vars: Query.Variable
    ) -> Iterator[Query.Variable]:
        """Alias of :meth:`Query.vars`."""
        return cls.Query.vars(var, *vars)

    @classmethod
    def as_qvar(cls, var: Variable) -> Query.Variable:
        """Constructs query variable from variable.

        Parameter:
           var: Variable.

        Returns:
           Query variable.
        """
        return cls.qvar(var.name)

    @classmethod
    def as_qvars(
            cls,
            var: Variable,
            *vars: Variable
    ) -> Iterator[Query.Variable]:
        """Constructs one or more query variables from variables.

        Parameters:
           var: Variable.
           vars: Variables.

        Returns:
           Iterator of query variables.
        """
        return map(cls.as_qvar, itertools.chain((var,), vars))

    #: Classes of variables corresponding to primitive SPARQL types.
    _primitive_var_classes: Final[tuple[type[Variable], ...]] = (
        DatatypeVariable,
        IRI_Variable,
        QuantityVariable,
        StringVariable,
        TimeVariable,
    )

    @classmethod
    def as_safe_qvar(cls, var: Variable) -> Query.Variable:
        """Constructs query variable from variable (safe).

        If variable is not of a primitive type, raises an error.

        Returns:
           Query variable.
        """
        if isinstance(var, cls._primitive_var_classes):
            return cls.as_qvar(var)
        else:
            raise TypeError(f'variable {var} is not of a primitive type')

    @classmethod
    def as_safe_qvars(
            cls,
            var: Variable,
            *vars: Variable
    ) -> Iterator[Query.Variable]:
        """Constructs one or more query variables from variables (safe).

        If one of the variables is not of a primitive type, raises an error.

        Parameters:
           var: Variable.
           vars: Variables.

        Returns:
           Iterator of query variables.
        """
        return map(cls.as_safe_qvar, itertools.chain((var,), vars))
