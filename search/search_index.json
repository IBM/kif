{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#knowledge-integration-framework","title":"Knowledge Integration Framework","text":"<p>KIF is a Python framework for knowledge integration from IBM Research.</p> <p>It is based on Wikidata and licensed under the open-source Apache-2.0 license.</p> <p>First time here? Check out the tutorial.</p> <p>Looking for the sources? See the GitHub repository.</p> <p> </p>"},{"location":"#hello-world","title":"Hello world!","text":"<p>Install KIF using pip:</p> <pre><code>$ pip install kif-lib\n</code></pre> <p>Use KIF to query Wikidata:</p> <pre><code>&gt;&gt;&gt; from kif_lib import Store\n&gt;&gt;&gt; from kif_lib.vocabulary import wd\n&gt;&gt;&gt; kb = Store('wikidata')\n&gt;&gt;&gt; next(kb.filter(subject=wd.Alan_Turing, property=wd.doctoral_advisor))\nStatement(Item(IRI('http://www.wikidata.org/entity/Q7251')), ValueSnak(...))\n</code></pre> <p>Or, via KIF CLI (the command-line interface):</p> <pre><code>$ pip install kif-lib[cli]    # KIF CLI is an optional dependency\n$ kif filter --subject=wd.Alan_Turing --property=wd.doctoral_advisor\n</code></pre> <p>(Statement (Item Alan Turing) (ValueSnak (Property doctoral advisor) (Item Alonzo Church)))</p> <p>KIF can also be used query other knowledge sources.  Here is a similar query over DBpedia (notice the <code>-s dbpedia</code> switch):</p> <pre><code>$ kif filter -s dbpedia --subject=db.Alan_Turing --property=wd.doctoral_advisor\n</code></pre> <p>(Statement (Item dbr:Alan_Turing) (ValueSnak (Property dbo:doctoralAdvisor) (Item dbr:Alonzo_Church)))</p> <p>The result is a stream of Wikidata-like statements containing DBpedia entities.</p>"},{"location":"#kif-in-a-nutshell","title":"KIF in a nutshell","text":"<p>KIF is a knowledge integration framework based on Wikidata.  The idea behind it is to use Wikidata to standardize the syntax and (whenever possible) the vocabulary of the integrated knowledge sources.  Users can then query the sources through filter patterns described in terms of the Wikidata data model.</p> <p>The integration done by KIF is virtual in the sense that syntax and vocabulary translations happen dynamically (at query time) and are guided by user-provided mappings.  KIF comes with built-in mappings for Wikidata, DBpedia, FactGrid, PubChem, and UniProt, among others.  New mappings can be added programmatically.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li> <p>KIF allows one to query knowledge sources as if they were Wikidata.</p> </li> <li> <p>KIF queries are written as simple, high-level filters using entities of the Wikidata data model, such as items, properties, quantities, snaks, statements, etc.</p> </li> <li> <p>KIF can be used to query Wikidata itself or other knowledge sources, provided proper mappings are given.</p> </li> <li> <p>KIF can run queries over local RDF data using RDFLib, Apache Jena, QLever, or RDFox.</p> </li> <li> <p>KIF has full support for Python's asyncio.  KIF async API can be used run queries asynchronously, without blocking waiting on their results.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install KIF, use:</p> <pre><code>$ pip install kif-lib\n</code></pre> <p>To include KIF CLI, use:</p> <pre><code>$ pip install kif-lib[cli]\n</code></pre> <p>To include all extras, use:</p> <pre><code>$ pip install kif-lib[extra]\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>KIF documentation is available at https://ibm.github.io/kif/.</p> <p>For a primer on KIF, see the tutorial.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Required:</p> <ul> <li>httpx - HTTP support.</li> <li>lark - Parsing.</li> <li>more_itertools - Extra itertools.</li> <li>networkx - Graph algorithms.</li> <li>rdflib - RDF support.</li> <li>typing-extensions - Typing backports.</li> </ul> <p>KIF CLI (optional):</p> <ul> <li>click - Option parsing. (Optional, with <code>kif-lib[cli]</code>)</li> <li>rich - Rich terminal support.  (Optional, with <code>kif-lib[cli]</code>)</li> </ul> <p>Extra (optional):</p> <ul> <li>graphviz - Graph drawing. (Optional, with <code>kif-lib[extra]</code>)</li> <li>jpype1 - Java support. (Optional, with <code>kif-lib[extra]</code>)</li> <li>pandas - CSV/DataFrame support. (Optional, with <code>kif-lib[extra]</code>)</li> <li>psutil - Process information. (Optional, with <code>kif-lib[extra]</code>)</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Guilherme Lima, Jo\u00e3o M.\u00a0B.\u00a0Rodrigues, Marcelo Machado, Elton Soares, Sandro R.\u00a0Fiorini, Raphael Thiago, Leonardo G.\u00a0Azevedo, Viviane T.\u00a0da Silva, Renato Cerqueira.  2024.  \"KIF: A Wikidata-Based Framework for Integrating Heterogeneous Knowledge Sources\", arXiv:2403.10304, 2024.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the KIF tutorial!</p> <p>Before we start, let's use the command-line to create and activate a fresh Python virtual environment:</p> <pre><code>$ python -m env tutorial\n$ source tutorial/bin/activate\n(tutorial) $\n</code></pre> <p>Let's us now use pip to install the latest release of kif-lib (with KIF CLI support) and then start an interactive Python session:</p> <pre><code>(tutorial) $ pip install kif-lib[cli]\n(tutorial) $ python\n&gt;&gt;&gt;\n</code></pre> <p>The rest of the tutorial will take place inside this interactive session.  From now on, we will omit the session prompt string (<code>&gt;&gt;&gt;</code>).</p>"},{"location":"tutorial/#1-first-steps","title":"1\u2002First steps","text":"<p>We start by importing the <code>Store</code> constructor from the KIF library:</p> <pre><code>from kif_lib import Store\n</code></pre> <p>We'll also need the Wikidata vocabulary module <code>wd</code>:</p> <pre><code>from kif_lib.vocabulary import wd\n</code></pre> <p>Now, let's create a KIF store pointing to the official Wikidata query service:</p> <pre><code>kb = Store('wikidata')\n</code></pre> <p>Note</p> <p>Wikidata is a general-purpose collaboratively edited knowledge graph maintained by the Wikimedia Foundation.  It can be thought of as a structured version of Wikipedia.</p> <p>A KIF store is an interface to a knowledge source.  It allows us to query the source as if it were Wikidata and obtain Wikidata-like statements as a result.</p> <p>The store <code>kb</code> (short for knowledge base) we just created is an interface to Wikidata itself.  We can use it, for example, to fetch from Wikidata three statements about Brazil (Q155):</p> PythonCLI <pre><code>it = kb.filter(subject=wd.Brazil, limit=3)\nfor stmt in it:\n   print(stmt)\n# -- output --\n# Statement(Item(IRI('http://www.wikidata.org/entity/Q155')), ValueSnak(Property(IRI('http://www.wikidata.org/entity/P47'), ItemDatatype()), Item(IRI('http://www.wikidata.org/entity/Q414'))))\n# Statement(Item(IRI('http://www.wikidata.org/entity/Q155')), ValueSnak(Property(IRI('http://www.wikidata.org/entity/P571'), TimeDatatype()), Time(datetime.datetime(1822, 9, 7, 0, 0, tzinfo=datetime.timezone.utc), 11, 0, Item(IRI('http://www.wikidata.org/entity/Q1985727')))))\n# Statement(Item(IRI('http://www.wikidata.org/entity/Q155')), ValueSnak(Property(IRI('http://www.wikidata.org/entity/P37'), ItemDatatype()), Item(IRI('http://www.wikidata.org/entity/Q5146'))))\n</code></pre> <pre><code>$ kif filter --store=wikidata --subject=wd.Brazil --limit=3\n(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina)))\n(Statement (Item Brazil) (ValueSnak (Property inception) 7 September 1822))\n(Statement (Item Brazil) (ValueSnak (Property official language) (Item Portuguese)))\n</code></pre> <p>Note</p> <p>Most Python examples shown in this tutorial can be reproduced on the command-line using KIF CLI.  Click on the \"CLI\" tab above to see the equivalent KIF CLI shell invocation.</p> <p>If you run the previous Python code in Jupyter and use <code>display()</code> instead of <code>print()</code>, then the three statements will be pretty-printed in S-expression format as follows:</p> <p>(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina))) (Statement (Item Brazil) (ValueSnak (Property inception) 7 September 1822)) (Statement (Item Brazil) (ValueSnak (Property official language) (Item Portuguese)))</p> <p>From now on, we'll use this pretty-printed format to display statements and their components.  (Note that KIF CLI uses this format by default.)</p> <p>A KIF statement represents an assertion and consists of two parts: a subject and a snak.  The subject is the entity about which the assertion is made, while the snak (or predication) is what is asserted about the subject.  The snak associates a property with a specific value, some value, or no value.</p> <p>Consider the first statement obtained from the store <code>kb</code> above:</p> <p>(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina)))</p> <p>This statement stands for the assertion \"Brazil shares border with Argentina\".  Its subject is the item Brazil (Q155) and its snak is a value snak which associates property shares border with (P47) with value Argentina (Q414).</p>"},{"location":"tutorial/#2-data-model","title":"2\u2002Data model","text":"<p>KIF data-model objects, such as statements and their components, are built using the data-model object constructors (see Data Model).  For instance, we can construct the statement \"Brazil shares border with Argentina\" as follows:</p> <pre><code>from kif_lib import Item, Property, Statement, ValueSnak\n\nBrazil = Item('http://www.wikidata.org/entity/Q155')\nshares_border_with = Property('http://www.wikidata.org/entity/P47')\nArgentina = Item('http://www.wikidata.org/entity/Q414')\n\nstmt = Statement(Brazil, ValueSnak(shares_border_with, Argentina))\nprint(stmt)\n</code></pre> <p>(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina)))</p> <p>Alternatively, we can apply the property object <code>shares_border_with</code> as if it were a Python function to the arguments <code>Brazil</code> and <code>Argentina</code> to obtain exactly the same statement:</p> <pre><code>stmt_alt = shares_border_with(Brazil, Argentina)\nprint(stmt_alt)\n</code></pre> <p>(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina)))</p> <p>Note</p> <p>KIF data-model objects are immutable: once constructed, they cannot be changed.  Also, data-model object identity is completely determined by the object contents.  This means that two data-model objects constructed from the same arguments will always test equal.  For example, <code>(stmt == stmt_alt) == True</code> above.</p> <p>To access the contents of statement objects, we can use the fields <code>subject</code> and <code>snak</code>:</p> <pre><code>print(stmt.subject, stmt.snak)\n</code></pre> <p>(Item Brazil) (ValueSnak (Property shares border with) (Item Argentina))</p> <p>Other data-model objects, such as entities, data values, and snaks, have analogous content-accessing fields (see Data Model):</p> <pre><code>print(stmt.subject.iri, stmt.snak.property, stmt.snak.value)\n</code></pre> <p>http://www.wikidata.org/entity/Q155 (Property shares border with) (Item Argentina)</p>"},{"location":"tutorial/#21-vocabulary","title":"2.1\u2002Vocabulary","text":"<p>KIF comes with built-in vocabulary modules that ease the construction of entities in certain namespaces.  For instance, instead of writing the full IRI of Wikidata entities, we can use the convenience functions <code>wd.Q</code> and <code>wd.P</code> from the Wikidata vocabulary module <code>wd</code> to construct the items Brazil (Q155) and Argentina (Q414) and the property shares border with (P47):</p> <pre><code>from kif_lib.vocabulary import wd\n\nBrazil = wd.Q(155)\nArgentina = wd.Q(414)\nshares_border_with = wd.P(47)\n\nprint(Brazil, Argentina, shares_border_with)\n</code></pre> <p>(Item Brazil) (Item Argentina) (Property shares border with)</p> <p>As before, we can apply <code>shares_border_with</code> to <code>Brazil</code> and <code>Argentina</code> to obtain the statement \"Brazil shares border with Argentina\":</p> <pre><code>stmt = shares_border_with(Brazil, Argentina)\nprint(stmt)\n</code></pre> <p>(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina)))</p> <p>The <code>wd</code> vocabulary module also defines symbolic aliases for popular entities.  Instead of writing <code>wd.Q(155)</code> and <code>wd.Q(414)</code> for Brazil and Argentina, we can write <code>wd.Brazil</code> and <code>wd.Argentina</code>.  Similarly, instead of writing <code>wd.P(47)</code> for \"shares border with\", we can write <code>wd.shares_border_with</code>.  Most Wikidata properties have symbolic aliases defined in <code>wd</code>.</p> <pre><code>print(wd.Brazil, wd.Argentina, wd.shares_border_with, wd.capital)\n</code></pre> <p>(Item Brazil) (Item Argentina) (Property shares border with) (Property capital)</p> <p>Note</p> <p>Besides <code>wd</code>, KIF comes with the vocabulary modules <code>db</code> for DBpedia, <code>fg</code> for FactGrid, <code>pc</code> for PubChem, <code>up</code> for UniProt, among others.</p>"},{"location":"tutorial/#3-store","title":"3\u2002Store","text":"<p>Let's now turn to the <code>Store</code> API.</p> <p>As we said earlier, a KIF store is an interface to a knowledge source, typically but not necessarily a knowledge graph.  A store is created using the <code>Store</code> constructor which takes as arguments the name of the store plugin to instantiate followed by zero or more arguments to be passed to the plugin.  For instance:</p> <pre><code>kb = Store('wikidata')\n</code></pre> <p>This instantiates and assigns to <code>kb</code> a new store using the \"wikidata\" plugin.  This plugin creates a SPARQL store, loads it with the Wikidata SPARQL mappings, and points it at the official Wikidata SPARQL endpoint.  (SPARQL is the query language of RDF, a standard format for knowledge graphs; see RDF.)</p> <p>Alternatively, we could have specified the target SPARQL endpoint explicitly, as the second argument to the <code>Store()</code> call:</p> <pre><code>kb = Store('wikidata', 'https://query.wikidata.org/sparql')\n</code></pre> <p>Note</p> <p>The available store plugins can be shown using KIF CLI:</p> <pre><code>$ kif show-plugins --store\n...\ndbpedia         : DBpedia SPARQL store\neuropa          : Europa (data.europa.eu) SPARQL store\nfactgrid        : FactGrid SPARQL store\npubchem         : PubChem SPARQL store\nuniprot         : UniProt SPARQL store\nwikidata        : Wikidata query service store\n...\n</code></pre>"},{"location":"tutorial/#4-filter","title":"4\u2002Filter","text":"<p>The basic store operation is the filter.</p> <p>The call <code>kb.filter(...)</code> searches for statements in <code>kb</code> matching the constraints <code>...</code>.  The result is a (lazy) iterator which when advanced produces the matched statements.  For example:</p> PythonCLI <pre><code>kb = Store('wikidata')\nit = kb.filter(subject=wd.Alan_Turing)\nprint(next(it))\n</code></pre> <pre><code>$ kif filter --store=wikidata --subject=wd.Alan_Turing\n\n# Note: We can omit --store=wikidata, as it is the default.\n</code></pre> <p>(Statement (Item Alan Turing) (ValueSnak (Property doctoral advisor) (Item Alonzo Church)))</p> <p>If no limit argument is given to <code>filter()</code>, the returned iterator will eventually produce all matching statements.  For instance, iterator <code>it</code> above will produce every statement with subject Alan Turing (Q7251) in Wikidata before it is exhausted.</p>"},{"location":"tutorial/#41-basic-filters","title":"4.1\u2002Basic filters","text":"<p>We can filter statements by specifying any combination of subject, property, value (or snak) to match.  None of these are required though.  For example:</p> PythonCLI <pre><code># (1) Match any statement whatsoever:\nit = kb.filter()\nprint(next(it))\n\n# (2) Match statements with subject \"water\":\nit = kb.filter(subject=wd.water)\nprint(next(it))\n\n# (3) Match statements with snak \"place of birth is Athens\":\nit = kb.filter(snak=wd.place_of_birth(wd.Athens))\nprint(next(it))\n\n# (4) Match statements with property \"official language\":\nit = kb.filter(property=wd.official_language)\nprint(next(it))\n\n# (5) Match statements with value \"733 kilograms\":\nit = kb.filter(value=733@wd.kilogram)\nprint(next(it))\n\n# (6) Match statements with subject \"Brazil\" and\n#     snak \"shares border with Argentina\":\nit = kb.filter(subject=wd.Brazil, snak=wd.shares_border_with(wd.Argentina))\nprint(next(it))\n\n# (7) Match statements with subject \"Brazil\" and\n#     snak \"shares border with Chile\":\nit = kb.filter(subject=wd.Brazil, snak=wd.shares_border_with(wd.Chile))\nprint(next(it)) # *** ERROR: iterator is empty (no such statement) ***\n</code></pre> <pre><code># (1) Match any statement whatsoever:\n$ kif filter --limit=1\n\n# (2) Match statements with subject \"water\":\n$ kif filter --subject=wd.water --limit=1\n\n# (3) Match statements with snak \"place of birth is Athens\":\n$ kif filter --snak=\"wd.place_of_birth(wd.Athens)\" --limit=1\n\n# (4) Match statements with property \"official language\":\n$ kif filter --property=wd.official_language --limit=1\n\n# (5) Match statements with value \"733 kilograms\":\n$ kif filter --value=733@wd.kilogram --limit=1\n\n# (6) Match statements with subject \"Brazil\" and\n#     snak \"shares border with Argentina\":\n$ kif filter --subject=wd.Brazil\\\n    --snak=\"wd.shares_border_with(wd.Argentina)\" --limit=1\n\n# (7) Match statements with subject \"Brazil\" and\n#     snak \"shares border with Chile\":\n$ kif filter --subject=wd.Brazil\\\n     --snak=\"wd.shares_border_with(wd.Chile)\" --limit=1\n# *** no output ***\n</code></pre> <p><code>(1)</code> (Statement (Item lion) (ValueSnak (Property parent taxon) (Item Panthera))) <code>(2)</code> (Statement (Item water) (ValueSnak (Property chemical formula) \"H\u2082O\")) <code>(3)</code> (Statement (Item Socrates) (ValueSnak (Property place of birth) (Item Athens))) <code>(4)</code> (Statement (Item Peru) (ValueSnak (Property official language) (Item Spanish))) <code>(5)</code> (Statement (Item Voyager 1) (ValueSnak (Property mass) 733 kilogram)) <code>(6)</code> (Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina)))</p> <p>Note</p> <p>In example (3) above, <code>wd.place_of_birth(wd.Athens)</code> is another way of constructing the snak <code>ValueSnak(wd.place_of_birth, wd.Athens)</code>, while in example (5), <code>733@wd.kilogram</code> is another way of constructing the quantity value <code>Quantity(733, wd.kilogram)</code> (see Data Model).</p> <p>In example (7), the filter failed to match any statement in Wikidata, as Brazil does not share a border with Chile.  So, the returned iterator is empty and we get a <code>StopIteration</code> exception when we try to advance it.</p> <p>Alternative subjects, properties, and values can be specified using Python's bitwise \"or\" operator (<code>|</code>):</p> PythonCLI <pre><code># (1) Match statements with subject \"Socrates\" or \"Plato\":\nit = kb.filter(subject=wd.Socrates|wd.Plato)\nprint(next(it))\n\n# (2) Match statements with subject \"caffeine\" and\n#     property \"density\" or \"mass\" or \"pKa\":\nit = kb.filter(subject=wd.caffeine, property=wd.density|wd.mass|wd.pKa)\nprint(next(it))\n\n# (3) Match statements with subject \"IBM\" and\n#     value \"16 June 1911\" or \"https://www.ibm.com/\":\nfrom kif_lib import IRI, Time\nit = kb.filter(\n    subject=wd.IBM, value=Time('1911-06-16')|IRI('https://www.ibm.com/'))\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># (1) Match statements with subject \"Socrates\" or \"Plato\":\n$ kif filter --subject=\"wd.Socrates|wd.Plato\" --limit=1\n\n# (2) Match statements with subject \"caffeine\" and\n#     property \"density\" or \"mass\" or \"pKa\":\n$ kif filter --subject=wd.caffeine\\\n    --property=\"wd.density|wd.mass|wd.pKa\" --limit=1\n\n# (3) Match statements with subject \"IBM\" and\n#     value \"16 June 1911\" or \"https://www.ibm.com/\":\n$ kif filter --subject=wd.IBM\\\n    --value=\"Time('1911-06-16')|IRI('https://www.ibm.com/')\" --limit=2\n</code></pre> <p><code>(1 )</code> (Statement (Item Plato) (ValueSnak (Property notable work) (Item The Republic))) <code>(2 )</code> (Statement (Item caffeine) (ValueSnak (Property mass) 194.08037556 dalton)) <code>(3a)</code> (Statement (Item IBM) (ValueSnak (Property official website) https://www.ibm.com/)) <code>(3b)</code> (Statement (Item IBM) (ValueSnak (Property inception) 16 June 1911))</p> <p>The <code>Or</code> constructor can be used to construct \"or\" compositions more conveniently from collection of values.  For example:</p> <pre><code>from kif_lib import Or\n\nsouth_america_countries = [wd.Brazil, wd.Argentina, wd.Uruguay, ...]\nit = kb.filter(subject=Or(*south_america_countries), property=wd.capital)\nfor stmt in it:\n    print(stmt)\n</code></pre> <p>(Statement (Item Argentina) (ValueSnak (Property capital) (Item Buenos Aires))) (Statement (Item Uruguay) (ValueSnak (Property capital) (Item Montevideo))) (Statement (Item Brazil) (ValueSnak (Property capital) (Item Bras\u00edlia))) \u22ee</p>"},{"location":"tutorial/#42-more-complex-filters","title":"4.2\u2002More complex filters","text":"<p>Suppose we want to match statements whose subjects are any items that \"share border with Argentina\".  If we know the subjects beforehand, we can specify them explicitly using the <code>|</code> operator:</p> <pre><code>it = kb.filter(subject=wd.Brazil|wd.Uruguay|wd.Chile|...))\n</code></pre> <p>Sometimes, however, we do not know the subjects beforehand.  In such cases, we can use a snak that captures the desired constraint, such as:</p> <pre><code>snak = wd.shares_border_with(wd.Argentina)\nprint(snak)\n</code></pre> <p>(ValueSnak (Property shares border with) (Item Argentina))</p> <p>The filter below matches statements such that the subject is any item that \"shares border with Argentina\", that is, any item <code>x</code> such that there is a statement <code>wd.shares_border_with(x, wd.Argentina)</code> in the store <code>kb</code>.</p> PythonCLI <pre><code>it = kb.filter(subject=wd.shares_border_with(wd.Argentina))\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code>$ kif filter  --subject=\"wd.shares_border_with(wd.Argentina)\"\n\n# Note: The double quotes (\") prevent the shell from interpreting the\n#       parentheses in the argument of --subject as a subshell invocation.\n</code></pre> <p>(Statement (Item Uruguay) (ValueSnak (Property public holiday) (Item Tourism Week))) (Statement (Item Bolivia) (ValueSnak (Property highest point) (Item Nevado Sajama))) (Statement (Item Paraguay) (ValueSnak (Property electrical plug type) (Item Europlug))) \u22ee</p> <p>These statements may seem random at first but they all have subjects matching the constraint \"shares border with Argentina\".</p> <p>Snak constraints such as <code>wd.shares_border_with(wd.Argentina)</code> can be given as subject, property, or value arguments to <code>filter()</code>.  Moreover, they can be combined with other constraints using the bitwise \"and\" (<code>&amp;</code>) and \"or\" (<code>|</code>) operators (or their prefixed versions <code>And</code> and <code>Or</code>).  For example:</p> PythonCLI <pre><code># (1) Subject's \"anthem is La Marseillaise\" and property is \"capital\":\nit = kb.filter(subject=wd.anthem(wd.La_Marseillaise), property=wd.capital)\nprint(next(it))\n\n# (2) Subject is \"water\" and property is any \"property related to chemistry\":\nit = kb.filter(subject=wd.water,\n    property=wd.instance_of(wd.Wikidata_property_related_to_chemistry))\nprint(next(it))\n\n# (3) Property is \"place of birth\" and value is the \"capital of Poland\":\nit = kb.filter(property=wd.place_of_birth, value=wd.capital_of(wd.Poland))\nprint(next(it))\n\n# (4) Subject's \"language is Portuguese\" &amp; \"shares border with Argentina\";\n#     Property is \"highest point\" | \"driving side\":\nit = kb.filter(\n    subject=(wd.official_language(wd.Portuguese)&amp;\n             wd.shares_border_with(wd.Argentina)),\n    property=wd.highest_point|wd.driving_side)\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># (1) Subject's \"anthem is La Marseillaise\" and property is \"capital\":\n$ kif filter --subject=\"wd.anthem(wd.La_Marseillaise)\"\\\n    --property=wd.capital --limit=1\n\n# (2) Subject is \"water\" and property is a \"property related to chemistry\":\n$ kif filter --subject=wd.water\\\n    --property=\"wd.instance_of(wd.Wikidata_property_related_to_chemistry)\"\\\n    --limit=1\n\n# (3) Property is \"place of birth\" and value is the \"capital of Poland\":\n$ kif filter --property=wd.place_of_birth --value=\"wd.capital_of(wd.Poland)\"\n\n# (4) Subject's \"language is Portuguese\" &amp; \"shares border with Argentina\";\n#     Property is \"highest point\" | \"driving side\":\n$ kif filter --subject=\"wd.official_language(wd.Portuguese)&amp;\\\n                        wd.shares_border_with(wd.Argentina)\"\\\n    --property=\"wd.highest_point|wd.driving_side\"\n</code></pre> <p><code>(1 )</code> (Statement (Item France) (ValueSnak (Property capital) (Item Paris))) <code>(2 )</code> (Statement (Item water) (ValueSnak (Property chemical formula) \"H\u2082O\")) <code>(3 )</code> (Statement (Item Marie Curie) (ValueSnak (Property place of birth) (Item Warsaw))) <code>(4a)</code> (Statement (Item Brazil) (ValueSnak (Property highest point) (Item Pico da Neblina))) <code>(4b)</code> (Statement (Item Brazil) (ValueSnak (Property driving side) (Item right)))</p> <p>Constraints that require traversing property paths of length greater than one can be specified using the sequencing operator <code>/</code>.  For example, the filter below matches statements such that:</p> <ul> <li> <p>the subject \"has some notable work in a collection which is part of the Louvre\"; and</p> </li> <li> <p>the property is \"handedness\".</p> </li> </ul> PythonCLI <pre><code>it = kb.filter(\n    subject=(wd.notable_work/wd.collection/wd.part_of)(wd.Louvre_Museum),\n    property=wd.handedness)\nprint(next(it))\n</code></pre> <pre><code>$ kif filter\\\n    --subject=\"(wd.notable_work/wd.collection/wd.part_of)(wd.Louvre_Museum)\"\\\n    --property=wd.handedness\n</code></pre> <p>(Statement (Item Leonardo da Vinci) (ValueSnak (Property handedness) (Item left-handedness)))</p>"},{"location":"tutorial/#43-masks-and-language","title":"4.3\u2002Masks and language","text":"<p>The parameters subject_mask, property_mask, and value_mask of <code>filter()</code> can be used to restrict the kinds of entities, properties, and values to be matched. For example:</p> PythonCLI <pre><code>from kif_lib import Filter\n\n# (1) Subject is \"Louvre Museum\" and value is an IRI:\nit = kb.filter(subject=wd.Wikidata, value_mask=Filter.IRI)\nprint(next(it))\n\n# (2) Subject is a property and value is a property:\nit = kb.filter(subject_mask=Filter.PROPERTY, value_mask=Filter.PROPERTY)\nprint(next(it))\n\n# (3) Subject is \"El Capitan\" and value is an external id or quantity:\nit = kb.filter(\n    subject=wd.El_Capitan, value_mask=Filter.EXTERNAL_ID|Filter.QUANTITY)\nprint(next(it))\n</code></pre> <pre><code># (1) Subject is \"Louvre Museum\" and value is an IRI:\n$ kif filter --subject=wd.Wikidata, value-mask=Filter.IRI\n\n# (2) Subject is a property and value is a property:\n$ kif filter --subject-mask=Filter.PROPERTY --value-mask=Filter.PROPERTY\n\n# (3) Subject is \"El Capitan\" and value is an external id or quantity:\n$ kif filter --subject=wd.El_Capitan\\\n    --value-mask=\"Filter.EXTERNAL_ID|Filter.QUANTITY\"\n</code></pre> <p><code>(1 )</code> (Statement (Item Louvre Museum) (ValueSnak (Property official website) https://www.louvre.fr/)) <code>(2 )</code> (Statement (Property part of the series) (ValueSnak (Property subproperty of) (Property part of))) <code>(3a)</code> (Statement (Item El Capitan) (ValueSnak (Property GeoNames ID) \"5334090\")) <code>(3b)</code> (Statement (Item El Capitan) (ValueSnak (Property elevation above sea level) 2307 metre))</p> <p>Note</p> <p>As illustrated in example (3) above, masks can be operated through the usual bitwise operators.  See <code>Filter</code> for the available mask types and values.</p> <p>Another mask parameter of <code>filter()</code> is snak_mask which determines the kinds of snaks to be matched.  So far, we have dealt only with value snaks (<code>ValueSnak</code>), which are essentially property-value pairs.  But KIF also supports, some-value snaks (<code>SomeValueSnak</code>) and no-value snaks (<code>NoValueSnak</code>), which carry only the predicated property.</p> <p>Some-value snaks represent predications with an unknown value, while no-value snaks represent predications with an absent value.  For instance, the fact that the Greek poet Homer's place of birth is unknown is represented in Wikidata by the some-value statement:</p> <p>(Statement (Item Homer) (SomeValueSnak (Property place of birth)))</p> <p>Similarly, the fact that the natural number 1 has no prime factor is represented by the no-value statement:</p> <p>(Statement (Item 1) (NoValueSnak (Property prime factor)))</p> <p>The kinds of snaks to be matched in filters are determined by the parameter snak_mask:</p> PythonCLI <pre><code># (1) Subject is \"Homer\" and snak is some-value:\nit = kb.filter(subject=wd.Homer, snak_mask=Filter.SOME_VALUE_SNAK)\nprint(next(it))\n\n# (2) Subject is \"1\" and snak is no-value:\nit = kb.filter(subject=wd._1, snak_mask=Filter.NO_VALUE_SNAK)\nprint(next(it))\n\n# (3) Subject is \"Adam\" and snak is some- or no-value:\nit = kb.filter(subject=wd.Adam,\n    snak_mask=Filter.SOME_VALUE_SNAK|Filter.NO_VALUE_SNAK, limit=2)\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># (1) Subject is \"Homer\" and snak is some-value:\n$ kif filter --subject=wd.Homer --snak-mask=Filter.SOME_VALUE_SNAK\n\n# (2) Subject is \"1\" and snak is no-value:\n$ kif filter --subject=wd._1 --snak-mask=Filter.NO_VALUE_SNAK\n\n# (3) Subject is \"Adam\" and snak is some- or no-value:\n$ kif filter --subject=wd.Adam\n    --snak-mask=\"Filter.SOME_VALUE_SNAK|Filter.NO_VALUE_SNAK\" --limit=2\n</code></pre> <p><code>(1 )</code> (Statement (Item Homer) (SomeValueSnak (Property place of birth))) <code>(2 )</code> (Statement (Item 1) (NoValueSnak (Property prime factor))) <code>(3a)</code> (Statement (Item Adam) (SomeValueSnak (Property date of birth))) <code>(3b)</code> (Statement (Item Adam) (NoValueSnak (Property father)))</p> <p>The last filter parameter we want to mention in this section is language, which controls the language of the returned text values.  If language is not given, <code>filter()</code> returns statements with text values in any language:</p> PythonCLI <pre><code># Subject is \"Mario\" and property is \"catchphrase\":\nit = kb.filter(subject=wd.Mario, property=wd.catchphrase)\nfor stmt in it:\n    print(next(it))\n</code></pre> <pre><code>$ kif filter --subject=wd.Mario --property=wd.catchphrase\n</code></pre> <p>(Statement (Item Mario) (ValueSnak (Property catchphrase) \"It\u2019s-a me, Mario!\"@en)) (Statement (Item Mario) (ValueSnak (Property catchphrase) \"Let\u2019s-a go!\"@en-us)) (Statement (Item Mario) (ValueSnak (Property catchphrase) \"Mamma mia!\"@it))</p> <p>However, we can set the language parameter to a language tag (\"en\", \"it\", \"fr\", \"pt\", etc.) to restrict the result to statements with text values in the desired language:</p> PythonCLI <pre><code># (1) Subject is \"Mario\", property is \"catchphrase\", value is in English:\nit = kb.filter(subject=wd.Mario, property=wd.catchphrase, language='en')\nprint(next(it))\n\n# (2) Subject is \"Mario\", property is \"catchphrase\", value is in Italian:\nit = kb.filter(subject=wd.Mario, property=wd.catchphrase, language='it')\nprint(next(it))\n</code></pre> <pre><code># (1) Subject is \"Mario\", property is \"catchphrase\", value is in English:\n$ kif filter --subject=wd.Mario --property=wd.catchphrase  --language=en\n\n# (2) Subject is \"Mario\", property is \"catchphrase\", value is in Italian:\n$ kif filter --subject=wd.Mario --property=wd.catchphrase --language=it\n</code></pre> <p><code>(1)</code> (Statement (Item Mario) (ValueSnak (Property catchphrase) \"It\u2019s-a me, Mario!\"@en)) <code>(2)</code> (Statement (Item Mario) (ValueSnak (Property catchphrase) \"Mamma mia!\"@it))</p>"},{"location":"tutorial/#44-projection","title":"4.4 Projection","text":"<p>Sometimes we are interested not in the full statements themselves but in their components.  For instance, suppose we want to list \"the capital cities of all US states\", that is, the entities representing the cities, not statements about them.  We can do this by first obtaining all has-capital statements whose subjects are US states and then printing only their value component:</p> <pre><code>it = kb.filter(subject=wd.instance_of(wd.US_state), property=wd.capital)\nfor (subj, (prop, value)) in it:\n    print(value)\n</code></pre> <p>(Item Indianapolis) (Item Phoenix) (Item Columbus) (Item Honolulu) \u22ee</p> <p>Note</p> <p>Every KIF data-model object can be decomposed into a sequence of components. The tuple pattern <code>(subj, (prop, value))</code> above decomposes the statement into a subject part <code>subj</code> and a value-snak part, which itself is decomposed into a property part <code>prop</code> and a value part <code>value</code>.  We could also have written:</p> <pre><code>for stmt in it:\n    print(stmt[1][0])\n</code></pre> <p>Or, using the <code>Statement</code> access fields:</p> <pre><code>for stmt in it:\n    print(stmt.snak.value)\n</code></pre> <p>See Data Model for details.</p> <p>A more convenient (and often more efficient) way of achieving the same thing is to use one of the projected variants of <code>filter()</code>.  In this case, we can use the variant <code>filter_v()</code>, which selects the value of the matched statements:</p> PythonCLI <pre><code>it = kb.filter_v(subject=wd.instance_of(wd.US_state), property=wd.capital)\nfor v in it:\n    print(v)\n</code></pre> <pre><code>$ kif filter --subject=\"wd.instance_of(wd.US_state)\"\n    --property=wd.capital --select=v\n\n# Note: The --select=v option instructs KIF CLI to use the filter_v()\n#       variant, that is, select the value of the returned statements.\n</code></pre> <p>The full list of projected variants of <code>filter()</code> is shown in the table below.  All of these variants accept exactly the same arguments as <code>filter()</code>.  The only difference is their return type.</p> filter variant selects returns <code>filter_s()</code> subject <code>Entity</code> <code>filter_p()</code> property <code>Property</code> <code>filter_v()</code> value <code>Value</code> <code>filter_sp()</code> subject, property <code>ValuePair</code> <code>filter_sv()</code> subject, value <code>ValuePair</code> <code>filter_pv()</code> property, value <code>ValueSnak</code>"},{"location":"tutorial/#5-pseudo-properties","title":"5\u2002Pseudo-properties","text":"<p>KIF extends the Wikidata data-model with the notion of pseudo-properties.  These are property-like entities which are not represented as properties in Wikidata.  For instance, labels, aliases, and descriptions are not represented as properties in Wikidata but are made available in KIF through the pseudo-properties <code>LabelProperty</code>, <code>AliasProperty</code>, <code>DescriptionProperty</code>.</p> <p>We can use pseudo-properties in filters as if they were regular properties:</p> PythonCLI <pre><code>from kif_lib import LabelProperty, AliasProperty, DescriptionProperty\n\n# (1) Get the Spanish label of Mars:\nit = kb.filter(subject=wd.Mars, property=LabelProperty(), language='es')\nprint(next(it))\n\n# (2) Get a French alias of Mars:\nit = kb.filter(subject=wd.Mars, property=AliasProperty(), language='fr')\nprint(next(it))\n\n# (3) Get the English description of Mars:\nit = kb.filter(subject=wd.Mars, property=DescriptionProperty(), language='en')\nprint(next(it))\n</code></pre> <pre><code># (1) Get the Spanish label of Mars:\n$ kif filter --subject=wd.Mars --property=\"LabelProperty()\" --language=es\n\n# (2) Get a French alias of Mars:\n$ kif filter --subject=wd.Mars --property=\"AliasProperty()\" --language=fr\n\n# (3) Get the English description of Mars:\n$ kif filter --subject=wd.Mars --property=\"DescriptionProperty\" --language=en\n</code></pre> <p><code>(1)</code> (Statement (Item Mars) (ValueSnak LabelProperty \"Marte\"@es)) <code>(2)</code> (Statement (Item Mars) (ValueSnak AliasProperty \"Plan\u00e8te rouge\"@fr)) <code>(3)</code> (Statement (Item Mars) (ValueSnak DescriptionProperty \"fourth planet in the Solar System from the Sun\"@en))</p> <p>The Wikidata vocabulary module <code>wd</code> defines the aliases <code>wd.label</code>, <code>wd.alias</code>, <code>wd.description</code> for the pseudo-properties <code>LabelProperty()</code>, <code>AliasProperty()</code>, <code>DescriptionProperty()</code>.  These can be used to write less verbose filter calls:</p> PythonCLI <pre><code># Get the label, aliases, and description of Mars in Portuguese:\nit = kb.filter(\n    subject=wd.Mars, property=wd.label|wd.alias|wd.description, language='pt')\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># Get the label, aliases, and description of Mars in Portuguese:\n$ kif filter --subject=wd.Mars\\\n    --property=\"wd.label|wd.alias|wd.description\" --language='pt'\n</code></pre> <p>(Statement (Item Mars) (ValueSnak LabelProperty \"Marte\"@pt)) (Statement (Item Mars) (ValueSnak AliasProperty \"planeta Marte\"@pt)) (Statement (Item Mars) (ValueSnak DescriptionProperty \"quarto planeta a partir do Sol no System Solar\"@pt))</p> <p>Note</p> <p>In KIF, the entity information comprising labels, aliases, and descriptions are referred to collectively as descriptors.  Descriptor values can be registered (saved) in the current KIF context so that, for example, they don't need to be retrieved every time an entity is pretty-printed (see Context).  Most vocabulary modules register in the KIF context the English label of the entities they define.  This cached label can be conveniently accessed through the <code>label</code> field of item and property objects:</p> <pre><code>print(wd.Q(111).label, wd.P(2583).label)\n</code></pre> <p>\"Mars\"@en \"distance from Earth\"@en</p> <p>The aliases and description can be accessed through the fields <code>aliases</code> and <code>description</code>.  These are usually left undefined by the vocabulary modules:</p> <pre><code>print(wd.Q(111).aliases, wd.P(2583).aliases)          # None None\nprint(wd.Q(111).description, wd.P(2583).description)  # None None\n</code></pre> <p>However, KIF can be instructed to retrieve them automatically using the vocabulary module's resolver.  This is done by setting option \"entities.resolve\" to <code>True</code> in the KIF context:</p> <pre><code># Enable automatic entity descriptor resolution:\nfrom kif_lib import Context\nContext.top().options.entities.resolve = True\n\n# (1)\nprint(wd.Q(111).aliases, wd.P(2583).aliases)\n\n# (2)\nprint(wd.Q(111).description, wd.P(2583).description)\n</code></pre> <p><code>(1a)</code> {\"Planet Mars\"@en, \"Red Planet\"@en} <code>(1b)</code> {\"angular diameter distance\"@en, \"proper distance\"@en, ...} <code>(2a)</code> \"fourth planet in the Solar System from the Sun\"@en <code>(2b)</code> \"estimated distance to astronomical objects\"@en</p> <p>Automatic entity descriptor resolution can also be enabled by setting the value of the environment variable <code>KIF_RESOLVE_ENTITIES</code> to 1 (or any other literal that evaluates to <code>True</code> in Python).  See Context for details.</p> <p>Some KIF pseudo-properties have no direct counterpart in Wikidata.  This is the case of the pseudo-properties <code>TypeProperty</code> and <code>SubtypeProperty</code>, whose <code>wd</code> aliases are <code>wd.a</code> and <code>wd.subtype</code>.  These pseudo-properties stand for the ontological relations \"is\u00a0a\" and \"subclass\u00a0of\", respectively, and can be seen as more powerful (transitivity-enabled) versions of the Wikidata properties instance of (P31) and subclass of (P279).</p> <p>To see the difference between <code>wd.a</code> and <code>wd.instance_of</code> consider the filter below. This filter gets statements that assert the classes of which rabbit (Q9394) is an instance:</p> PythonCLI <pre><code># Get the classes such that \"rabbit\" is an instance of:\nit = kb.filter(subject=wd.rabbit, property=wd.instance_of)\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># Get the classes such that \"rabbit\" is an instance of:\n$ kif filter --subject=wd.rabbit --property=wd.instance_of\n</code></pre> <p>(Statement (Item rabbit) (ValueSnak (Property instance of) (Item organisms known by a particular common name))) (Statement (Item rabbit) (ValueSnak (Property instance of) (Item taxon)))</p> <p>If we now replace <code>wd.instance_of</code> by <code>wd.a</code>, we get three times more results:</p> PythonCLI <pre><code># Get the classes such that \"rabbit\" is an instance of (with transitivity):\nit = kb.filter(subject=wd.rabbit, property=wd.a)\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># Get the classes such that \"rabbit\" is an instance of (with transitivity):\n$ kif filter --subject=wd.rabbit --property=wd.a\n</code></pre> <p>(Statement (Item rabbit) (ValueSnak TypeProperty (Item group or class of living things))) (Statement (Item rabbit) (ValueSnak TypeProperty (Item organisms known by a particular common name))) (Statement (Item rabbit) (ValueSnak TypeProperty (Item group or class of physical objects))) (Statement (Item rabbit) (ValueSnak TypeProperty (Item collective entity))) (Statement (Item rabbit) (ValueSnak TypeProperty (Item taxon))) (Statement (Item rabbit) (ValueSnak TypeProperty (Item entity)))</p> <p>What is happening here is that the latter version considers as classes such that rabbit is an instance not only organisms known by a particular common name (Q55983715) and taxon (Q16521) but also any super-classes of these two.  In other words, while <code>wd.instance_of</code> looks only to the immediate class, <code>wd.a</code> traverses the whole class hierarchy.</p> <p>The pseudo-property <code>wd.subtype</code>, which is the transitive counterpart of <code>wd.subclass_of</code>, behaves similarly:</p> PythonCLI <pre><code># (1) Get the subclasses of \"mammal\":\nit = kif.filter(subject=wd.mammal, --property=wd.subclass_of)\nfor stmt in it:\n    print(stmt)\n\n# (2) Get the subclasses of \"mammal\" (with transitivity):\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># (1) Get the subclasses of \"mammal\":\n$ kif filter --subject=wd.mammal --property=wd.subclass_of\n\n# (2) Get the subclasses of \"mammal\" (with transitivity):\n$ kif filter --subject=wd.mammal --property=wd.subtype\n</code></pre> <p><code>(1 )</code> (Statement (Item mammal) (ValueSnak (Property subclass of) (Item Vertebrata))) <code>(2a)</code> (Statement (Item mammal) (ValueSnak SubtypeProperty (Item animal))) <code>(2b)</code> (Statement (Item mammal) (ValueSnak SubtypeProperty (Item Vertebrata))) <code>(2c)</code> (Statement (Item mammal) (ValueSnak SubtypeProperty (Item organism))) \u22ee</p> <p>We emphasize that pseudo-properties can occur in any place where a regular property is expected.  That is, they can be used to construct snak constraints, paths, etc.  For example:</p> PythonCLI <pre><code># (1) Get the \"breeds\" of all \"fictional dogs\":\nit = kb.filter_v(subject=(wd.a/wd.fictional_or_mythical_analog_of)(wd.dog),\n    property=wd.animal_breed)\nfor value in it:\n    print(value)\n\n# (2) Get the subject and value of \"instance of\" statements such that\n#     the subject has the Portuguese label \"laranja\":\nit = kb.filter_sv(subject=wd.label(Text(\"laranja\", \"pt\")),\n    property=wd.instance_of)\nfor pair in it:\n    print(pair)\n</code></pre> <pre><code># (1) Get the breeds of all fictional dogs:\n$ kif filter --subject=\"(wd.a/wd.fictional_or_mythical_analog_of)(wd.dog)\"\\\n    --property=wd.animal_breed --select=v\n\n# (2) Get the subject and value of instance-of statements such that\n#     the subject has label \"laranja\"@pt:\n$ kif filter --subject=\"wd.label(Text('laranja', 'pt'))\"\\\n    --property=wd.instance_of  --select=sv\n</code></pre> <p><code>(1a)</code> (Item Welsh Corgi) <code>(1b)</code> (Item pit bull) <code>(1c)</code> (Item collie) \u22ee <code>(2a)</code> (ValuePair (Item orange) (Item secondary color)) <code>(2b)</code> (ValuePair (Item orange) (Item web color)) <code>(2c)</code> (ValuePair (Item orange) (Item spectral color)) \u22ee</p>"},{"location":"tutorial/#6-statement-annotations","title":"6\u2002Statement annotations","text":"<p>Up to now, we have dealt only with plain statements (<code>Statement</code>).  These are statements consisting of a subject, a snak, and nothing else.  In KIF, statements can also carry extra information referred to collectively as annotations.  These statements with annotations (or annotated statements, see <code>AnnotatedStatement</code>) behave exactly as plain statements but besides a subject and a snak also carry a set of qualifiers, a set of reference records, and a rank.  The qualifiers qualify the statement assertion, the reference records contain provenance information, and the rank indicates the quality of the statement.</p> <p>The boolean parameter annotated instructs the <code>filter()</code> method to obtain the annotations associated with each returned statement.  The variant <code>filter_annotated()</code> can also be used to filter annotated statements.  (It behaves exactly as <code>filter()</code> with the annotated flag set to <code>True</code> but its return type is <code>AnnotatedStatement</code> instead of <code>Statement</code>.)</p> <p>The difference between <code>filter()</code> and <code>filter_annotated()</code> is illustrated in examples (1) and (2) below:</p> PythonCLI <pre><code># (1) Get the \"density\" of \"benzene\":\nit = kb.filter(subject=wd.benzene, property=wd.density)\nprint(next(it))\n\n# (2) Get the \"density\" of \"benzene\" (with annotations):\nit = kb.filter_annotated(subject=wd.benzene, property=wd.density)\nprint(next(it))\n</code></pre> <pre><code># (1) Get the \"density\" of \"benzene\":\n$ kif filter --subject=wd.benzene --property=wd.density\n\n# (2) Get the \"density\" of \"benzene\" (with annotations):\n$ kif filter --subject=wd.benzene --property=wd.density --annotated\n\n# Note: The --annotated flag instructs KIF CLI to fetch annotations.\n</code></pre> <p><code>(1)</code> (Statement (Item benzene) (ValueSnak (Property density) 0.88 \u00b10.01 gram per cubic centimetre)) <code>(2)</code> (AnnotatedStatement (Item benzene) (ValueSnak (Property density) 0.88 \u00b10.01 gram per cubic centimetre) \u2003(QualifierRecord \u2003\u2003(ValueSnak (Property temperature) 20 \u00b11 degree Celsius) \u2003\u2003(ValueSnak (Property phase of matter) (Item liquid))) \u2003(ReferenceRecordSet \u2003\u2003\u2003(ReferenceRecord \u2003\u2003\u2003\u2003(ValueSnak (Property HSDB ID) \"35#section=TSCA-Test-Submissions\") \u2003\u2003\u2003\u2003(ValueSnak (Property stated in) (Item Hazardous Substances Data Bank)))) NormalRank)</p> <p>Both statements, (1) and (2), assert that \"benzene's density is 0.88\u00b10.01 g/cm\".  But statement (2), which is annotated, carries more information.  Its qualifier record qualifies the assertion, i.e., says in addition that this is the case when \"the temperature is 20\u00b11\u00a0\u2103\" and \"the phase of matter is liquid\".  Its reference record set contains a single reference record which indicates the provenance of the statement, namely, the entry with the given HSDB ID in the Hazardous Substances Data Bank.  Finally, its rank is \"normal\" which is the default one and means that its status is neutral (neither preferred nor deprecated).</p> <p>Note</p> <p>The <code>QualifierRecord</code> is essentially a set of snaks, while the reference record set is a set of <code>ReferenceRecord</code> objects, each of which is itself a snak set.  Element repetition and ordering within these set objects are immaterial.  See Data Model for details.</p> <p>Note</p> <p>The <code>filter</code> parameter rank_mask can be used to match statements with a given rank (<code>NormalRank</code>, <code>PreferredRank</code>, <code>DeprecatedRank</code>; see Data Model).</p> <p>As plain statements, annotated statements can be constructed directly using data-model object constructors.  For instance, <code>stmt2a</code> and <code>stmt2b</code> below correspond exactly to statement (2) above.</p> <pre><code>from kif_lib import (AnnotatedStatement, NormalRank,\n                     QualifierRecord, Quantity,\n                     ReferenceRecord, ReferenceRecordSet, ValueSnak)\n\nstmt2a = AnnotatedStatement(\n    wd.benzene,\n    ValueSnak(\n        wd.density,\n        Quantity('.88', wd.gram_per_cubic_centimetre, '.87', '.89')),\n    QualifierRecord(\n        wd.temperature(Quantity(20, wd.degree_Celsius, 19, 21)),\n        wd.phase_of_matter(wd.liquid)),\n    ReferenceRecordSet(\n        ReferenceRecord(\n            wd.HSDB_ID('35#section=TSCA-Test-Submissions'),\n        wd.stated_in(wd.Hazardous_Substances_Data_Bank))),\n    NormalRank())\n\nstmt2b = wd.density(\n    wd.benzene, Quantity('.88', wd.gram_per_cubic_centimetre, '.87', '.89'),\n    qualifiers=[\n        wd.temperature(Quantity(20, wd.degree_Celsius, 19, 21)),\n        wd.phase_of_matter(wd.liquid)],\n    references=[[\n        wd.HSDB_ID('35#section=TSCA-Test-Submissions'),\n        wd.stated_in(wd.Hazardous_Substances_Data_Bank)]],\n    rank=NormalRank())\n\nprint(stmt2a == stmt2b)           # True\n</code></pre> <p>If we already have a statement, then we can use the method <code>annotate()</code> to create an annotated version of it.  For example:</p> <pre><code>stmt3 = wd.density(\n    wd.benzene, Quantity('.88', wd.gram_per_cubic_centimetre, '.87', '.89'))\n\nstmt4 = stmt3.annotate(\n    qualifiers=[\n        wd.temperature(Quantity(20, wd.degree_Celsius, 19, 21)),\n        wd.phase_of_matter(wd.liquid)],\n    references=[[\n        wd.HSDB_ID('35#section=TSCA-Test-Submissions'),\n        wd.stated_in(wd.Hazardous_Substances_Data_Bank)]],\n    rank=NormalRank())\n\nprint(stmt2a == stmt2b == stmt4)  # True\nprint(stmt3 == stmt4)             # False\n</code></pre> <p>Conversely, if we have an annotated statement we can use the method <code>unannotated()</code> to obtain its plain version:</p> <pre><code>print(stmt3 == stmt4.unannotate()  # True\n</code></pre>"},{"location":"tutorial/#7-ask-count-mix","title":"7\u2002Ask, count, mix","text":"<p>We now turn to other query methods available in the <code>Store</code> API.</p> <p>Two variants of the filter call are <code>kb.ask(...)</code> and <code>kb.count(...)</code>.  The former tests whether some (at least one) statement in <code>kb</code> matches the constraints <code>...</code>, while the latter counts the number of statements in <code>kb</code> matching <code>...</code>.  Both variants accept exactly the same constraint arguments as <code>filter()</code>.</p> <p>Here are some examples of <code>ask()</code> and <code>count()</code>:</p> PythonCLI <pre><code># Ask whether there are statements with subject \"caffeine\":\nb = kb.ask(subject=wd.caffeine)\nprint(b)  # True\n\n# Count statements with snak \"place of death is New York City\":\nn = kb.count(snak=wd.place_of_death(wd.New_York_City))\nprint(n)  # 13491\n\n# Ask whether there are some- or no-value statements whose\n# subject is \"a singer buried in Paris\":\nb = kb.ask(subject=wd.occupation(wd.singer)&amp;wd.place_of_burial(wd.Paris),\n        snak_mask=Filter.SOME_VALUE_SNAK|Filter.NO_VALUE_SNAK)\nprint(b)  # False\n\n# Count statements whose subject is \"a dish originating in Italy\",\n# property is \"has part(s)\", and value is \"tomato\":\nn = kb.count(subject=wd.subtype(wd.dish)&amp;wd.country_of_origin(wd.Italy),\n        property=wd.has_parts, value=wd.tomato)\nprint(n)  # 17\n\n# [Ask whether there are / count] statements \"Brazil shares border with Chile\":\nb = kb.ask(subject=wd.Brazil, property=wd.shares_border_with, value=wd.Chile)\nn = kb.count(subject=wd.Brazil, property=wd.shares_border_with, value=wd.Chile)\nprint(b, n)  # False, 0\n</code></pre> <pre><code># Ask whether there are statements with subject \"caffeine\":\n$ kif ask --subject=wd.caffeine; echo $?\n0\n\n# Count statements with snak \"place of death is New York City\":\n$ kif count --snak=\"wd.place_of_death(wd.New_York_City)\"\n13491\n\n# Ask whether there are some- or no-value statements whose\n# subject is \"a singer buried in Paris\":\n$ kif ask --subject=\"wd.occupation(wd.singer)&amp;wd.place_of_burial(wd.Paris)\"\\\n    --snak-mask=\"Filter.SOME_VALUE_SNAK|Filter.NO_VALUE_SNAK\"; echo $?\n1\n\n# Count statements whose subject is \"a dish originating in Italy\",\n# property is \"has part(s)\", and value is \"tomato\":\n$ kif count --subject=\"wd.subtype(wd.dish)&amp;wd.country_of_origin(wd.Italy)\"\\\n    --property=wd.has_parts --value=wd.tomato\n17\n\n# [Ask whether there are / count] statements \"Brazil shares border with Chile\":\n$kif ask --subject=wd.Brazil\\\n    --property=wd.shares_border_with --value=wd.Chile; echo $?\n1\n\n$ kif count --subject=wd.Brazil\\\n    --property=wd.shares_border_with --value=wd.Chile\n0\n\n# Note: The ask command exits with status 0 if any matching statements\n# where found; otherwise it exits with status 1.  We use \"echo $?\" above\n# to display its exit status.\n</code></pre> <p>Note</p> <p>One important difference between <code>filter()</code> and <code>ask()</code> and <code>count()</code> is that, while <code>filter()</code> returns a lazy iterator, meaning that the underlying filter operation is only performed when the iterator is advanced, the operations underlying <code>ask()</code> and <code>count()</code> are executed immediately.</p> <p>The method count() also comes with projected variants (<code>s</code>, <code>p</code>, <code>v</code>, <code>sp</code>, <code>sv</code>, <code>pv</code>) which can be used to count the number of distinct statement components matching the given constraints.  For example:</p> PythonCLI <pre><code># Counts the number of distinct properties used in statements with\n# subject \"cat\":\nn = kb.count_p(subject=wd.cat)\nprint(n)  # 123\n</code></pre> <pre><code># Counts the number of distinct properties used in statements with\n# subject \"cat\":\n$ kif count --subject=wd.cat --select=p\n123\n</code></pre> <p>Another method of the <code>Store</code> API that deserves mention is <code>mix()</code>.  It is used to run multiple filters at once, combining the resulting statements into a single output stream.  For example, suppose we want to match statements such that either:</p> <ul> <li>the subject is \"Brazil\" and the value is \"Argentina\"; or</li> <li>the subject is \"France\" and the value is \"United Kingdom\".</li> </ul> <p>Note that in this case we want to match alternative subject-value pairs, which cannot be written as a single filter.  Using <code>mix()</code> we can write this as two separate filters and get their results combined:</p> <pre><code>from kif_lib import Filter\n\nit = kb.mix(\n    Filter(subject=wd.Brazil, value=wd.Argentina),\n    Filter(subject=wd.France, value=wd.United_Kingdom))\nfor stmt in it:\n    print(stmt)\n</code></pre> <p>(Statement (Item Brazil) (ValueSnak (Property shares border with) (Item Argentina))) (Statement (Item France) (ValueSnak (Property diplomatic relation) (Item United Kingdom))) (Statement (Item Brazil) (ValueSnak (Property diplomatic relation) (Item Argentina)))</p> <p>The <code>Filter</code> constructor used above builds a data-model representation of a filter pattern.  It takes as arguments exactly the same constraints as <code>filter()</code>.  Alternatively, we could have used <code>kb.filter()</code> calls directly:</p> <pre><code>it = kb.mix(\n    kb.filter(subject=wd.Brazil, value=wd.Argentina),\n    kb.filter(subject=wd.France, value=wd.United_Kingdom))\nfor stmt in it:\n    print(stmt)\n</code></pre> <p>Note</p> <p>The <code>mix()</code> call evaluates its filter arguments in the order they are given and interleaves their results.  There is no parallelism though, as each filter evaluation causes the calling thread to block.  One way to avoid blocking the calling thread during each filter evaluation is to use Python's async mechanism.  To this end, the <code>Store</code> API provides the async versions <code>afilter</code>, <code>aask</code>, <code>acount</code>, and <code>amix</code>.  These behave exactly like their sync counterparts but can be awaited within an asyncio event-loop.  See Async for details.</p>"},{"location":"tutorial/#8-beyond-wikidata","title":"8\u2002Beyond Wikidata","text":"<p>We begin this section using DBpedia to demonstrate KIF's ability to query knowledge sources other than Wikidata.  We chose DBpedia mainly because, besides being supported by KIF out-of-the-box, like Wikidata, it allows us to write mundane examples, which can be understood by everybody.  Besides Wikidata and DBpedia, KIF comes with builtin support for FactGrid, PubChem, UniProt, among other sources.  Most of what is illustrated below using DBpedia can be easily adapted to work with these other sources.</p> <p>Note</p> <p>DBpedia is a popular knowledge graph of general-purpose information extracted from Wikipedia.  FactGrid is a knowledge graph of historical data maintained by Gotha Research Centre (Germany).  PubChem is a database of chemical data maintained the US National Institutes of Health (NIH).  UniProt is a database of protein data maintained by the UniProt consortium.</p>"},{"location":"tutorial/#81-dbpedia","title":"8.1\u2002DBpedia","text":"<p>To query a knowledge source other than Wikidata, all we need to do is create a new store using a different plugin.  Here is how we create a store targeting DBpedia:</p> <pre><code>kb_dbp = Store('dbpedia')\n</code></pre> <p>The \"dbpedia\" plugin creates a SPARQL store, loads it with the DBpedia SPARQL mappings, and points it at the official DBpedia SPARQL endpoint.  The result is a new store <code>kb_dbp</code> to which we can apply filters to obtain DBpedia statements:</p> PythonCLI <pre><code># Match any statement whatsoever:\nit = kb_dbp.filter(limit=3)\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code># Match any statement whatsoever:\n$ kif filter --store=dbpedia --limit=3\n\n# Note: The --store=dbpedia option instructs KIF CLI to use as target\n#       a store instantiated with the \"dbpedia\" plugin, instead of the\n#       default one (--store=wikidata).\n</code></pre> <p>(Statement (Item Mark Twain) (ValueSnak (Property birth name) \"Samuel Langhorne Clemens\"@en)) (Statement (Item Garfield) (ValueSnak (Property author) (Item Jim Davis (cartoonist)))) (Statement (Item Camelot) (ValueSnak (Property ruler) (Item King Arthur)))</p> <p>The result of the previous filter is a stream of statements following the Wikidata syntax but with entities in the DBpedia namespace.</p> <p>Note</p> <p>KIF's DBpedia SPARQL mappings do not attempt to convert entities in the DBpedia namespace into that of Wikidata.  The exception are Wikidata properties which, as we'll see in a moment, are converted by the DBpedia SPARQL mappings into equivalent DBpedia properties whenever possible.</p> <p>We can use the DBpedia vocabulary module <code>db</code> to write filters referring to DBpedia entities.  For example:</p> PythonCLI <pre><code>from kif_lib.vocabulary import db\n\n# (1) Match statements with subject \"Banana\":\nit = kb_dbp.filter(subject=db.r('Banana'))\nprint(next(it))\n\n# (2) Match statements with snak \"place of birth is Sicily\":\nit = kb_dbp.filter(snak=db.op('birthPlace')(db.r('Sicily')))\nprint(next(it))\n\n# (3) Match statements with property \"official language\":\nit = kb_dbp.filter(property=db.op('officialLanguage'))\nprint(next(it))\n\n# (4) Match statements with value 733:\nit = kb_dbp.filter(value=733)\nprint(next(it))\n\n# (5) Match statements with subject \"Brazil\" and\n#     snak \"capital is Bras\u00edlia\":\nit = kb_dbp.filter(subject=db.r('Brazil'),\n    snak=db.op('capital')(db.r('Bras\u00edlia')))\nprint(next(it))\n\n# (6) Match statements with subject \"Brazil\" and\n#     snak \"capital is S\u00e3o Paulo\":\nit = kb_dbp.filter(subject=db.r('Brazil'),\n    snak=db.op('capital')(db.r('S\u00e3o_Paulo')))\nprint(next(it)) # *** ERROR: iterator is empty (no such statement) ***\n</code></pre> <pre><code># (1) Match statements with subject \"Banana\":\n$ kif filter -s dbpedia --subject=\"db.r('Banana')\" --limit=1\n\n# (2) Match statements with snak \"birth place is Sicily\":\n$ kif filter -s dbpedia --snak=\"db.op('birthPlace')(db.r('Sicily'))\" --limit=1\n\n# (3) Match statements with property \"official language\":\n$ kif filter -s dbpedia --property=db.op('officialLanguage') --limit=1\n\n# (4) Match statements with value 733:\n$ kif filter -s dbpedia --value=733 --limit=1\n\n# (5) Match statements with subject \"Brazil\" and\n#     snak \"capital is Bras\u00edlia\":\n$ kif filter -s dbpedia --subject=\"db.r('Brazil')\"\\\n    --snak=\"db.op('capital')(db.r('Bras\u00edlia'))\" --limit=1\n\n# (6) Match statements with subject \"Brazil\" and\n#     snak \"capital is S\u00e3o Paulo\":\n$ kif filter -s dbpedia --subject=\"db.r('Brazil')\"\\\n    --snak=\"db.op('capital')(db.r('S\u00e3o_Paulo'))\" --limit=1\n# *** no output ***\n\n# Note: \"-s dbpedia\" is an alias for \"--store=dbpedia\".\n</code></pre> <p><code>(1)</code> (Statement (Item Banana) (ValueSnak (Property genus) (Item Musa (genus)))) <code>(2)</code> (Statement (Item Archimedes) (ValueSnak (Property birth place) (Item Sicily))) <code>(3)</code> (Statement (Item Cameroon) (ValueSnak (Property official language) (Item French language))) <code>(4)</code> (Statement (Item Mosquito County, Florida) (ValueSnak (Property population total) 733)) <code>(5)</code> (Statement (Item Brazil) (ValueSnak (Property capital) (Item Bras\u00edlia)))</p> <p>Different from Wikidata, DBpedia uses symbolic names for identifying entities in its namespace.  Also, it distinguishes between resources (<code>db.r</code>), ontology concepts (<code>db.oc</code>), ontology properties (<code>db.op</code>), and properties (<code>db.p</code>).  The first two, resources and ontology concepts, are interpreted by the DBpedia SPARQL mappings as KIF items (Item), while the last two, ontology properties and properties, are interpreted as KIF properties (Property).  The DBpedia vocabulary module db defines aliases for some of the ontology properties.  So, for example, we can write <code>db.birthPlace</code> for <code>db.op('birthPlace')</code>, <code>db.capital</code> for <code>db.op('capital')</code>, and so on.</p> <p>By default, the DBpedia SPARQL mappings attempt to convert Wikidata properties into DBpedia properties whenever such mapping information is available in DBpedia.  This means that it supports the use of Wikidata properties directly in filters.  For example:</p> PythonCLI <pre><code>from kif_lib.vocabulary import wd\n\n# Get the \"place of birth\" of \"Jim Morrison\":\nit = kb_dbp(subject=db.r('Jim_Morrison'), property=wd.place_of_birth)\nprint(next(it))\n</code></pre> <pre><code># Get the \"place of birth\" of \"Jim Morrison\":\n$ kif filter -s dbpedia \"db.r('Jim_Morrison')\" wd.place_of_birth --limit=1\n</code></pre> <p>(Statement (Item Jim Morrison) (ValueSnak (Property place of birth) (Item Melbourne, Florida)))</p> <p>Notice that we used the Wikidata property place of birth (P19) instead of dbo:birthPlace above.  This works because these two properties are declared \"equivalent\" in DBpedia.  Similarly, if we ask for all properties leaving the node dbr:Jim_Morrison, we get as results not only DBpedia properties but also Wikidata properties, including place of birth (P19):</p> PythonCLI <pre><code>it = kb_dbp.filter_p(subject=db.r('Jim_Morrison'))\nfor prop in it:\n    print(prop)\n</code></pre> <pre><code>$ kif filter -s dbpedia --subject=\"db.r('Jim_Morrison')\" --select=p\n</code></pre> <p>DBpedia properties: (Property burial place) (Property birth place) (Property parents) (Property occupation) \u22ee Wikidata properties: (Property educated at) (Property place of birth) (Property occupation) (Property place of death) \u22ee</p> <p>The DBpedia store <code>kb_dbp</code> supports all features discussed in the previous sections, including complex filter constraints, masks, projections, pseudo-properties, and the ask(), count(), and mix() operations.  Here are some examples:</p> PythonCLI <pre><code># (1) Subject's \"capital is Paris\" and property is \"anthem\":\nit = kb_dbp.filter(subject=wd.capital(db.r('Paris')), property=wd.anthem)\nprint(next(it))\n\n# (2) Subject was \"influenced by Bertrand Russell\" &amp;\n#     \"educated at University of Vienna\"; property is \"description\"; and\n#     value is in English:\nit = kb_dbp.filter(\n    subject=(-db.p('influenced')(db.r('Bertrand_Russell'))&amp;\n             wd.educated_at(db.r('University_of_Vienna'))),\n    property=wd.description, language='en')\nprint(next(it))\n\n# (3) Get the subject and value of statements with property \"doctoral student\"\n#     and value which \"died of a condition caused by Cyanide\":\nit = kb_dbp.filter_sv(property=db.doctoralStudent,\n    value=(wd.cause_of_death/db.op('medicalCause'))(db.r('Cyanide')))\nprint(next(it))\n\n# (4) Same as (3) but count the number of matches:\nn = kb_dbp.count_sv(property=db.doctoralStudent,\n    value=(wd.cause_of_death/db.op('medicalCause'))(db.r('Cyanide')))\nprint(n)  # 1\n</code></pre> <pre><code># (1) Subject's \"capital is Paris\" and property is \"anthem\":\n$ kif filter -s dbpedia --subject=\"wd.capital(db.r('Paris'))\"\\\n    --property=wd.anthem\n\n# (2) Subject was \"influenced by Bertrand Russell\" &amp;\n#     \"educated at University of Vienna\"; property is \"description\"; and\n#     value is in English:\n$ kif filter -s dbpedia\\\n    --subject=\"-db.p('influenced')(db.r('Bertrand_Russell'))&amp;\\\n               wd.educated_at(db.r('University_of_Vienna'))\"\\\n    --property=wd.description --language=en --limit=1\n\n# (3) Get the subject and value of statements with property \"doctoral student\"\n#     and value which \"died of a condition caused by Cyanide\":\n$ kif filter -s dbpedia --property=db.doctoralStudent\\\n    --value=\"(wd.cause_of_death/db.op('medicalCause'))(db.r('Cyanide'))\"\\\n    --select=sv --limit=1\n\n# (4) Same as (3) but count the number of matches:\n$ kif count -s dbpedia --property=db.doctoralStudent\\\n    --value=\"(wd.cause_of_death/db.op('medicalCause'))(db.r('Cyanide'))\"\\\n    --select=sv\n1\n</code></pre> <p><code>(1)</code> (Statement (Item France) (ValueSnak (Property anthem) (Item La Marseillaise))) <code>(2)</code> (Statement (Item Kurt G\u00f6del) (ValueSnak DescriptionProperty \"Kurt Friedrich G\u00f6del (/\u02c8\u0261\u025c\u02d0rd\u0259l/ GUR-d\u0259l, German: [k\u028a\u0281t \u02c8\u0261\u00f8\u02d0dl\u0329]; April 28, 1906 \u2013 January 14, 1978) was a logician, mathematician, and philosopher. Considered along with Aristotle and Gottlob Frege to be one of the most significant logicians in history, G\u00f6del had an immense effect upon scientific and philosophical thinking in the 20th century, a time when others such as Bertrand Russell, Alfred North Whitehead, and David Hilbert were using logic and set theory to investigate the foundations of mathematics, building on earlier work by the likes of Richard Dedekind, Georg Cantor and Frege.\"@en)) <code>(3)</code> (ValuePair (Item Alonzo Church) (Item Alan Turing))</p> <p>Note</p> <p>In example (2) above, the unary minus operator <code>-</code> is used in the subject constraint to invert the direction of the relation dbp:influenced.  That is, by writing <code>-db.p('influenced')(db.r('Bertrand_Russell'))</code> we match the <code>x</code> such that there is a dbp:influenced edge in the graph with source dbo:Bertrand_Russell and target <code>x</code>.  Still in example (2), notice that we use in the same filter the DBpedia property dbp:influenced, the Wikidata property educated at (P69), and the pseudo property <code>wd.description</code>.</p>"},{"location":"tutorial/#82-mixer-store","title":"8.2\u2002Mixer store","text":"<p>We've seen how to construct stores targeting individual knowledge sources.  KIF also comes with the \"mixer\" store plugin which allows us to combine multiple stores to into a new store.  For example:</p> <pre><code>mx = Store('mixer', [Store('wikidata'), Store('dbpedia'), Store('factgrid')])\n</code></pre> <p>This instantiates and assigns to <code>mx</code> a new mixer store with three child stores, namely, SPARQL stores targeting Wikidata, DBpedia, and FactGrid.  The mixer store acts as a proxy to the child stores.  It provides a unified interface for querying them as if they were single knowledge source.</p> <p>When we evaluate a <code>filter()</code> over <code>mx</code>, we get all statements from the child stores that match the filter.  For example:</p> PythonCLI <pre><code>it = mx.filter(subject=wd.label('Joan of Arc'), value_snak=Filter.TIME))\nfor stmt in it:\n    print(stmt)\n</code></pre> <pre><code>$ kif filter -s wikidata -s dbpedia -s factgrid\\\n    --subject=\"wd.label('Joan of Arc')\" --value-mask=Filter.TIME\n\nNote: When multiple stores are given using option \"-s\", KIF CLI adds\n      all of them to a new mixer store, which becomes the target store.\n</code></pre> <p>Wikidata: (Statement (Item Joan of Arc) (ValueSnak (Property date of death) 8 June 1431)) DBpedia: (Statement (Item Joan of Arc) (ValueSnak (Property death date) 30 May 1431)) FactGrid: (Statement (Item Joan of Arc) (ValueSnak (Property Date of death) 8 June 1431)) \u22ee</p> <p>The filter above matches statements whose subject has label \"Joan of Arc\" and value is a time value.  The result is a stream of statements obtained by combining (by default, interleaving) the streams produced by <code>mx</code>'s children.  The first statement shown above comes from Wikidata, the second from DBpedia, and the third from FactGrid.  The three concern the date of death of Joan of Arc but, because they come from distinct sources, they use different IRIs for the item \"Joan of Arc\" and the property \"date of death\".  Also, while Wikidata and FactGrid agree on the date, 8th June 1431, the DBpedia asserts that the event took place on 30th May 1431.</p> <p>The mixer store tends to be more useful when the child stores adopt the same namespace, or at least can handle entities in the namespaces of the other children.  This is the case, for example, of the DBpedia SPARQL mappings, which can handle Wikidata properties.  In contrast, the FactGrid SPARQL mappings use a namespace that is completely separate from Wikidata's and cannot handle Wikidata entities (at least for now).</p> <p>KIF also comes with SPARQL mappings for PubChem, which is one of the largest open databases of chemical data.  KIF's PubChem SPARQL mappings support Wikidata properties natively.  This includes properties for universal chemical identifiers which can be used for matching compounds across knowledge sources.  In the example below, we create a mixer store <code>mx_wd_pc</code> combining both, Wikidata and PubChem SPARQL stores, and then use it to obtain annotated statements about the molecular mass of a given chemical (benzene) from these sources:</p> <pre><code>kb_wd = Store('wikidata', extra_references=[[wd.stated_in(wd.Wikidata)]])\nkb_pc = Store('pubchem', 'https://localhost:1234/sparql',\n    extra_references=[[wd.stated_in(wd.PubChem)]])\nkb_wd_pc = Store('mixer', [kb_wd, kb_pc])\n\nit = kb_wd_pc.filter(subject=wd.InChIKey('UHOVQNZJYSORNB-UHFFFAOYSA-N'),\n    property=wd.mass, annotated=True)\nfor stmt in it:\n    print(stmt)\n</code></pre> <p>(AnnotatedStatement (Item benzene) (ValueSnak (Property mass) 78.046950192 dalton) \u2003(QualifierRecord) \u2003(ReferenceRecordSet \u2003\u2003(ReferenceRecord \u2003\u2003\u2003(ValueSnak (Property stated in) (Item Wikidata))) \u2003\u2003(ReferenceRecord \u2003\u2003\u2003(ValueSnak (Property based on heuristic) (Item inferred from InChI)))) NormalRank)</p> <p>(AnnotatedStatement (Item [6]annulene) (ValueSnak (Property mass) 78.0469970703125 dalton) \u2003(QualifierRecord) \u2003(ReferenceRecordSet \u2003\u2003(ReferenceRecord \u2003\u2003\u2003(ValueSnak (Property stated in) (Item PubChem)))) NormalRank)</p> <p>There are a couple of things to notice here.</p> <ol> <li> <p>PubChem does not provide a public SPARQL endpoint, only RDF dumps.  The code above (line\u00a02) assumes that a SPARQL endpoint loaded with PubChem data is available at the address http://localhost:1234/sparql.</p> </li> <li> <p>We use the extra_references parameter of the Store() constructor (lines\u00a01\u20132) to associate to the Wikidata and PubChem stores extra reference records.  These extra records will be attached by the stores to every annotated statement they produce, allowing us to tell which store generated each statement.</p> </li> <li> <p>To avoid using a source-dependent identifier for the benzene, we use its InChIKey string \"UHOVQNZJYSORNB-UHFFFAOYSA-N\" (line\u00a06), which is a universal identifier.  This works because property <code>wd.InChIKey</code> is recognized by both SPARQL mappings Wikidata's and PubChem's.  Similarly, <code>wd.mass</code> (line\u00a07) is also recognized by both.</p> </li> </ol>"},{"location":"tutorial/#9-entity-search","title":"9\u2002Entity search","text":"<p>Besides stores, the other kind of data-model object producing engine in KIF are the searchers.  A KIF searcher is an interface to a similarity search method within a namespace.  KIF searchers follow the <code>Search</code> API which is implemented using a plugin architecture.  For example, given a search string, the \"wikidata\" search plugin uses the Wikidata's MediaWiki REST API to look in the Wikidata namespace for entities with a similar label, alias, or description:</p> PythonCLI <pre><code>from kif_lib import Search\n\nsr = Search('wikidata')\nit = sr.item('pizza', limit=3)\nfor item in it:\n    print(item)\n</code></pre> <pre><code>$ kif search --search=wikidata 'pizza' --item --limit=3\n\n# Note: We can omit --search=wikidata, as it is the default\n</code></pre> <p>(Item pizza) (Item Mariagrazia Pizza) (Item Pizza Hut)</p> <p>The Search() constructor creates a new searcher using the given plugin.  In the example above, we used plugin \"wikidata\" to look for at most three items with descriptors matching the search string \"pizza\".  The items found are returned in order of relevance, from most relevant to least relevant.  The top three items found above refer to the food item, to a person (a pharmaceutical chemist), and to the American restaurant chain.</p> <p>The <code>sr.item()</code> call we used above searches for and returns items.  A related call in the <code>Search</code> API is <code>item_descriptor()</code> which in addition to the items returns any available descriptors.  For example:</p> PythonCLI <pre><code>it = sr.item_descriptor('pizza', limit=3)\nfor item, desc in it:\n    print(item, desc)\n</code></pre> <pre><code>$ kif search --search=wikidata 'pizza' --item-descriptor --limit=3\n\n# Note: The \"--item-descriptor\" option instructs the searcher to obtain\n#       any available descriptors.\n</code></pre> <p>(Item pizza) {'labels': {'en': \"pizza\"@en}, 'descriptions': {'en': \"Italian universal popular dish with a flat dough-based base and toppings\"@en}} (Item Mariagrazia Pizza) {'labels': {'en': \"Mariagrazia Pizza\"@en}, 'descriptions': {'en': \"pharmaceutical chemist\"@en}, 'aliases': {'en': {\"Pizza\"@en}}} (Item Pizza Hut) {'labels': {'en': \"Pizza Hut\"en}, 'descriptions': {'en': \"American restaurant chain and international franchise\"@en}}</p> <p>The Search API also provides the methods <code>property()</code> and <code>property_descriptor()</code> for searching for properties.</p> <p>Note</p> <p>The <code>Search</code> API provides the async versions <code>aitem</code>, <code>aitem_descriptor</code>, <code>aproperty</code>, and <code>aproperty_descriptor</code>.  As in the case of stores, the async versions behave exactly like their sync counterparts but can be awaited within an asyncio event-loop.  See Async for details.</p> <p>KIF comes with built-in plugins to search for entities in the namespaces of Wikidata, DBpedia, and PubChem.  There is also the general \"ddgs\" plugin, based on the DDGS library, which can used to search for entities in any namespace reachable through the public Internet.</p> <p>Note</p> <p>The available search plugins can be shown using KIF CLI:</p> <pre><code>$ kif show-plugins --search\n...\ndbpedia             : DBpedia Lookup API search\ndbpedia-ddgs        : DBpedia DDGS search\nddgs                : DDGS search\npubchem             : PubChem PUG search\npubchem-ddgs        : PubChem DDGS search\nwikidata            : Wikidata Wikibase API search\nwikidata-ddgs       : Wikidata DDGS search\nwikidata-rest       : Wikidata REST search\nwikidata-wapi-query : Wikidata Wikibase API search (\"query\" action)\n...\n</code></pre>"},{"location":"tutorial/#10-final-remarks","title":"10\u2002Final remarks","text":"<p>This concludes the KIF tutorial.</p> <p>Check out the guides and the API reference for a detailed description of KIF features, including those which were left out of the tutorial.</p> <p>Have fun!</p>"},{"location":"api/context/","title":"Context","text":""},{"location":"api/context/#kif_lib.Context","title":"<code>Context</code>","text":"<p>KIF context.</p>"},{"location":"api/context/#kif_lib.Context.entities","title":"<code>entities</code>  <code>property</code>","text":"<p>The entity registry.</p>"},{"location":"api/context/#kif_lib.Context.iris","title":"<code>iris</code>  <code>property</code>","text":"<p>The IRI registry.</p>"},{"location":"api/context/#kif_lib.Context.options","title":"<code>options</code>  <code>property</code>","text":"<p>The options of context.</p>"},{"location":"api/context/#kif_lib.Context.get_aliases","title":"<code>get_aliases(entity, language=None, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the aliases of item or property in registry.</p> <p>Parameters:</p> <ul> <li> <code>entity</code>               (<code>Item | Property</code>)           \u2013            <p>Item or property.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve aliases.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Set[Text] | None</code>           \u2013            <p>Aliases or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_category","title":"<code>get_category(lexeme, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the lexical category of lexeme in registry.</p> <p>Parameters:</p> <ul> <li> <code>lexeme</code>               (<code>Lexeme</code>)           \u2013            <p>Lexeme.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve lexical category.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item | None</code>           \u2013            <p>Item or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_description","title":"<code>get_description(entity, language=None, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the description of item or property in registry.</p> <p>Parameters:</p> <ul> <li> <code>entity</code>               (<code>Item | Property</code>)           \u2013            <p>Item or property.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve description.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Description or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_entities","title":"<code>get_entities()</code>","text":"<p>Gets the entity registry.</p> <p>Returns:</p> <ul> <li> <code>EntityRegistry</code>           \u2013            <p>Entity registry.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_inverse","title":"<code>get_inverse(property, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the inverse of property in registry.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>Property</code>)           \u2013            <p>Property.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve inverse.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property | None</code>           \u2013            <p>Property or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_iris","title":"<code>get_iris()</code>","text":"<p>Gets the IRI registry.</p> <p>Returns:</p> <ul> <li> <code>IRI_Registry</code>           \u2013            <p>IRI registry.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_label","title":"<code>get_label(entity, language=None, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the label of item or property in registry.</p> <p>Parameters:</p> <ul> <li> <code>entity</code>               (<code>Item | Property</code>)           \u2013            <p>Item or property.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve label.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Label or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_language","title":"<code>get_language(lexeme, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the language of lexeme in registry.</p> <p>Parameters:</p> <ul> <li> <code>lexeme</code>               (<code>Lexeme</code>)           \u2013            <p>Lexeme.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve language.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item | None</code>           \u2013            <p>Item or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_lemma","title":"<code>get_lemma(lexeme, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the lemma of lexeme in registry.</p> <p>Parameters:</p> <ul> <li> <code>lexeme</code>               (<code>Lexeme</code>)           \u2013            <p>Lexeme.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve lemma.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Text or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_option_by_name","title":"<code>get_option_by_name(name)</code>","text":"<p>Gets option by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>Option name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The option value.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`KeyError`</code>             \u2013            <p>No such option.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_option_description_by_name","title":"<code>get_option_description_by_name(name)</code>","text":"<p>Gets option description by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>Option name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The option description.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`KeyError`</code>             \u2013            <p>No such option.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_options","title":"<code>get_options()</code>","text":"<p>Gets the options of context.</p> <p>Returns:</p> <ul> <li> <code>Options</code>           \u2013            <p>Options.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_prefix","title":"<code>get_prefix(iri, function=None)</code>","text":"<p>Gets the prefix of IRI in registry.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>T_IRI</code>)           \u2013            <p>IRI.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Prefix or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_range","title":"<code>get_range(property, resolve=None, resolver=None, force=None, function=None)</code>","text":"<p>Gets the range of property in registry.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>Property</code>)           \u2013            <p>Property.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve range.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Datatype | None</code>           \u2013            <p>Range or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_resolver","title":"<code>get_resolver(iri, function=None)</code>","text":"<p>Gets the entity resolver of IRI or entity in registry.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>T_IRI | Entity</code>)           \u2013            <p>IRI.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Store | None</code>           \u2013            <p>Store or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.get_schema","title":"<code>get_schema(iri, function=None)</code>","text":"<p>Gets the property schema of IRI or property in registry.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>T_IRI | Property</code>)           \u2013            <p>IRI.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema | None</code>           \u2013            <p>Property schema or <code>None</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.resolve","title":"<code>resolve(objects, resolver=None, batch_size=None, label=False, aliases=False, description=False, language=None, range=False, inverse=False, lemma=False, category=False, lexeme_language=False, all=False, force=None, function=None)</code>","text":"<p>Resolves entity data.</p> <p>Traverses <code>objects</code> recursively and resolves the data of every entity found into context's entity registry.</p> <p>If <code>resolver</code> is given, uses it to resolve entity data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>objects</code>               (<code>Iterable[T]</code>)           \u2013            <p>Objects.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>batch_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Batch size for resolver calls.</p> </li> <li> <code>label</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve labels.</p> </li> <li> <code>aliases</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve aliases.</p> </li> <li> <code>description</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve descriptions.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>range</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve ranges.</p> </li> <li> <code>inverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve inverses.</p> </li> <li> <code>lemma</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve lemmas.</p> </li> <li> <code>category</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve lexical categories.</p> </li> <li> <code>lexeme_language</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve lexeme languages.</p> </li> <li> <code>all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to resolve all data.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolve.</p> </li> <li> <code>batch_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Batch size.</p> </li> <li> <code>function</code>               (<code>Location | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[T]</code>           \u2013            <p><code>objects</code>.</p> </li> </ul>"},{"location":"api/context/#kif_lib.Context.top","title":"<code>top(context=None)</code>  <code>classmethod</code>","text":"<p>Gets the current context.</p> <p>If <code>context</code> is not <code>None</code>, returns <code>context</code>.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>Context.</p> </li> </ul>"},{"location":"api/engine/","title":"Engine","text":""},{"location":"api/engine/#kif_lib.engine.Engine","title":"<code>Engine</code>","text":"<p>               Bases: <code>Generic[TOptions]</code></p> <p>Abstract base class for KIF object producing engines.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.debug","title":"<code>debug</code>  <code>property</code> <code>writable</code>","text":"<p>The debug flag of engine (whether debugging is enabled).</p>"},{"location":"api/engine/#kif_lib.engine.Engine.default_debug","title":"<code>default_debug</code>  <code>property</code>","text":"<p>The default value for :attr:<code>Engine.debug</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.default_limit","title":"<code>default_limit</code>  <code>property</code>","text":"<p>The default value for :attr:<code>Engine.limit</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.default_lookahead","title":"<code>default_lookahead</code>  <code>property</code>","text":"<p>The default value for :attr:<code>Engine.lookahead</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.default_page_size","title":"<code>default_page_size</code>  <code>property</code>","text":"<p>The default value for :attr:<code>Engine.page_size</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.default_timeout","title":"<code>default_timeout</code>  <code>property</code>","text":"<p>The default value for :attr:<code>Engine.timeout</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.limit","title":"<code>limit</code>  <code>property</code> <code>writable</code>","text":"<p>The limit of engine (maximum number of responses).</p>"},{"location":"api/engine/#kif_lib.engine.Engine.lookahead","title":"<code>lookahead</code>  <code>property</code> <code>writable</code>","text":"<p>The lookahead of engine.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.max_limit","title":"<code>max_limit</code>  <code>property</code>","text":"<p>The maximum value for :attr:<code>Engine.limit</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.max_page_size","title":"<code>max_page_size</code>  <code>property</code>","text":"<p>The maximum value for :attr:<code>Engine.page_size</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.max_timeout","title":"<code>max_timeout</code>  <code>property</code>","text":"<p>The maximum value for :attr:<code>Engine.timeout</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.options","title":"<code>options</code>  <code>property</code>","text":"<p>The options of engine.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.page_size","title":"<code>page_size</code>  <code>property</code> <code>writable</code>","text":"<p>The page size of engine (size of response pages).</p>"},{"location":"api/engine/#kif_lib.engine.Engine.timeout","title":"<code>timeout</code>  <code>property</code> <code>writable</code>","text":"<p>The timeout of engine (in seconds).</p>"},{"location":"api/engine/#kif_lib.engine.Engine.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for engine errors.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.__init__","title":"<code>__init__(*args, debug=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Initializes :class:<code>Engine</code>.</p> <p>Parameters:</p> <ul> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Arguments.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Async version of :meth:<code>Engine.close</code>.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.close","title":"<code>close()</code>","text":"<p>Closes engine.</p>"},{"location":"api/engine/#kif_lib.engine.Engine.get_context","title":"<code>get_context(context=None)</code>  <code>classmethod</code>","text":"<p>Gets the current KIF context.</p> <p>If <code>context</code> is not <code>None</code>, returns <code>context</code>.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>Context.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_debug","title":"<code>get_debug()</code>","text":"<p>Gets the debug flag of engine.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Debug flag.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_default_debug","title":"<code>get_default_debug()</code>","text":"<p>Gets the default value for :attr:<code>Engine.debug</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Default debug flag.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_default_limit","title":"<code>get_default_limit()</code>","text":"<p>Gets the default value for :attr:<code>Engine.limit</code>.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Default limit or <code>None</code>.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_default_lookahead","title":"<code>get_default_lookahead()</code>","text":"<p>Gets the default value for :attr:<code>Engine.lookahead</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Default lookahead value.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_default_options","title":"<code>get_default_options(context=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Gets the default options of engine.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TOptions</code>           \u2013            <p>Engine options.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_default_page_size","title":"<code>get_default_page_size()</code>","text":"<p>Gets the default value for :attr:<code>Engine.page_size</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Default page size.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_default_timeout","title":"<code>get_default_timeout()</code>","text":"<p>Gets the default value for :attr:<code>Engine.timeout</code>.</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>Timeout or <code>None</code>.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_limit","title":"<code>get_limit(default=None)</code>","text":"<p>Gets the limit of engine.</p> <p>If the limit is <code>None</code>, returns <code>default</code>.</p> <p>If <code>default</code> is <code>None</code>, assumes :attr:<code>Engine.default_limit</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Default limit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Limit or <code>None</code>.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_lookahead","title":"<code>get_lookahead()</code>","text":"<p>Gets the lookahead of engine.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Lookahead.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_max_limit","title":"<code>get_max_limit()</code>","text":"<p>Gets the maximum value for :attr:<code>Engine.limit</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Maximum limit.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_max_page_size","title":"<code>get_max_page_size()</code>","text":"<p>Gets the maximum value for :attr:<code>Engine.page_size</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Maximum page size.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_max_timeout","title":"<code>get_max_timeout()</code>","text":"<p>Gets the maximum value for :attr:<code>Engine.timeout</code>.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Maximum timeout (in seconds).</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_options","title":"<code>get_options()</code>","text":"<p>Gets the options of engine.</p> <p>Returns:</p> <ul> <li> <code>TOptions</code>           \u2013            <p>Engine options.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_page_size","title":"<code>get_page_size()</code>","text":"<p>Gets the page size of engine.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Page size.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.get_timeout","title":"<code>get_timeout(default=None)</code>","text":"<p>Gets the timeout of engine.</p> <p>If the timeout is <code>None</code>, returns <code>default</code>.</p> <p>If <code>default</code> is <code>None</code>, assumes :attr:<code>Engine.default_timeout</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Default timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>Timeout or <code>None</code>.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.set_debug","title":"<code>set_debug(debug=None)</code>","text":"<p>Sets the debug flag of engine.</p> <p>If <code>debug</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Debug flag.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.set_limit","title":"<code>set_limit(limit=None)</code>","text":"<p>Sets the limit of engine.</p> <p>If <code>limit</code> is negative, assumes zero.</p> <p>If <code>limit</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.set_lookahead","title":"<code>set_lookahead(lookahead=None)</code>","text":"<p>Sets the lookhead of engine.</p> <p>If <code>lookahead</code> is negative, assumes one.</p> <p>If <code>lookahead</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Lookahead.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.set_page_size","title":"<code>set_page_size(page_size=None)</code>","text":"<p>Sets the page size of engine.</p> <p>If <code>page_size</code> is negative, assumes zero.</p> <p>If <code>page_size</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size.</p> </li> </ul>"},{"location":"api/engine/#kif_lib.engine.Engine.set_timeout","title":"<code>set_timeout(timeout=None)</code>","text":"<p>Sets the timeout of engine.</p> <p>If <code>timeout</code> is negative, assumes zero.</p> <p>If <code>timeout</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout.</p> </li> </ul>"},{"location":"api/overview/","title":"Overview","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"},{"location":"api/compiler/sparql/builder/","title":"SPARQL Query Builder","text":""},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder","title":"<code>builder</code>","text":""},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Aggregate","title":"<code>Aggregate</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>Abstract base class for aggregates.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.And","title":"<code>And</code>","text":"<p>               Bases: <code>LogicExpression</code></p> <p>Conjunction.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.AskClause","title":"<code>AskClause</code>","text":"<p>               Bases: <code>Clause</code></p> <p>ASK clause.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.AskQuery","title":"<code>AskQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>ASK query.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.AtomicGraphPattern","title":"<code>AtomicGraphPattern</code>","text":"<p>               Bases: <code>GraphPattern</code></p> <p>Abstract base class for atomic graph patterns.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.BNODE","title":"<code>BNODE</code>","text":"<p>               Bases: <code>ZeroAryBuiltInCall</code></p> <p>The BNODE built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-bnode.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.BOUND","title":"<code>BOUND</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>The BOUND built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-bound.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.BinaryBuiltInCall","title":"<code>BinaryBuiltInCall</code>","text":"<p>               Bases: <code>BuiltInCall</code></p> <p>Abstract base class for 2-ary built-in calls.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Bind","title":"<code>Bind</code>","text":"<p>               Bases: <code>Pattern</code></p> <p>Bind pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.BooleanExpression","title":"<code>BooleanExpression</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Abstract base class for boolean expressions.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.BuiltInCall","title":"<code>BuiltInCall</code>","text":"<p>               Bases: <code>Call</code></p> <p>Abstract base class for built-in function calls.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.COALESCE","title":"<code>COALESCE</code>","text":"<p>               Bases: <code>BuiltInCall</code></p> <p>The COALESCE built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-coalesce.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.COUNT","title":"<code>COUNT</code>","text":"<p>               Bases: <code>Aggregate</code></p> <p>The COUNT aggregate built-in.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.COUNT_STAR","title":"<code>COUNT_STAR</code>","text":"<p>               Bases: <code>COUNT</code></p> <p>The COUNT aggregate built-in with argument set to star (*).</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Call","title":"<code>Call</code>","text":"<p>               Bases: <code>NumericExpression</code></p> <p>Abstract base class for function calls.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Clause","title":"<code>Clause</code>","text":"<p>               Bases: <code>Encodable</code></p> <p>Abstract base class for clauses.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Coerce","title":"<code>Coerce</code>","text":"<p>Type-checking and coercion functions.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Comment","title":"<code>Comment</code>","text":"<p>               Bases: <code>Pattern</code></p> <p>Comment pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.CommentsBlock","title":"<code>CommentsBlock</code>","text":"<p>               Bases: <code>AtomicGraphPattern</code></p> <p>Comments block.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.CompoundGraphPattern","title":"<code>CompoundGraphPattern</code>","text":"<p>               Bases: <code>GraphPattern</code></p> <p>Abstract base class for compound graph patterns.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Encodable","title":"<code>Encodable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for \"encodable\" objects.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Equal","title":"<code>Equal</code>","text":"<p>               Bases: <code>RelationalExpression</code></p> <p>Equality test.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Expression","title":"<code>Expression</code>","text":"<p>               Bases: <code>Encodable</code></p> <p>Abstract base class for expressions.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Filter","title":"<code>Filter</code>","text":"<p>               Bases: <code>Pattern</code></p> <p>Filter pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.FilterNotExistsGraphPattern","title":"<code>FilterNotExistsGraphPattern</code>","text":"<p>               Bases: <code>CompoundGraphPattern</code></p> <p>FILTER NOT EXISTS graph pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.GraphPattern","title":"<code>GraphPattern</code>","text":"<p>               Bases: <code>Pattern</code></p> <p>Abstract base class for graph patterns.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.GreaterThan","title":"<code>GreaterThan</code>","text":"<p>               Bases: <code>RelationalExpression</code></p> <p>Greater-than test.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.GreaterThanOrEqual","title":"<code>GreaterThanOrEqual</code>","text":"<p>               Bases: <code>RelationalExpression</code></p> <p>Greater-than-or-equal test.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.GroupGraphPattern","title":"<code>GroupGraphPattern</code>","text":"<p>               Bases: <code>CompoundGraphPattern</code></p> <p>Group graph pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.IF","title":"<code>IF</code>","text":"<p>               Bases: <code>TernaryBuiltInCall</code></p> <p>The IF built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-if.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.IsBlank","title":"<code>IsBlank</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>The isURI built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-isBlank.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.IsLiteral","title":"<code>IsLiteral</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>The isLiteral built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-isLiteral.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.IsURI","title":"<code>IsURI</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>The isURI built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-isIRI.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.LANG","title":"<code>LANG</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>The LANG built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-lang.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.LessThan","title":"<code>LessThan</code>","text":"<p>               Bases: <code>RelationalExpression</code></p> <p>Less-than test.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.LessThanOrEqual","title":"<code>LessThanOrEqual</code>","text":"<p>               Bases: <code>RelationalExpression</code></p> <p>Less-than-or-equal test.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.LimitClause","title":"<code>LimitClause</code>","text":"<p>               Bases: <code>Clause</code></p> <p>LIMIT clause.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.LogicExpression","title":"<code>LogicExpression</code>","text":"<p>               Bases: <code>BooleanExpression</code></p> <p>Abstract base class for logic expressions.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.NamedSubSelectBlock","title":"<code>NamedSubSelectBlock</code>","text":"<p>               Bases: <code>SubSelectBlock</code></p> <p>Named sub-select block.</p> <p>This is an extension supported by Blazegraph.</p> <p>See https://github.com/blazegraph/database/wiki/NamedSubquery.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Not","title":"<code>Not</code>","text":"<p>               Bases: <code>LogicExpression</code></p> <p>Negation.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.NotEqual","title":"<code>NotEqual</code>","text":"<p>               Bases: <code>RelationalExpression</code></p> <p>Not-equal test.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.NumericExpression","title":"<code>NumericExpression</code>","text":"<p>               Bases: <code>BooleanExpression</code></p> <p>Abstract base class for numeric expressions.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.NumericLiteral","title":"<code>NumericLiteral</code>","text":"<p>               Bases: <code>NumericExpression</code></p> <p>Numeric literal.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.OffsetClause","title":"<code>OffsetClause</code>","text":"<p>               Bases: <code>Clause</code></p> <p>OFFSET clause.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.OptionalGraphPattern","title":"<code>OptionalGraphPattern</code>","text":"<p>               Bases: <code>CompoundGraphPattern</code></p> <p>OPTIONAL graph pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>LogicExpression</code></p> <p>Disjunction.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.OrderByClause","title":"<code>OrderByClause</code>","text":"<p>               Bases: <code>Clause</code></p> <p>ORDER BY clause.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Pattern","title":"<code>Pattern</code>","text":"<p>               Bases: <code>Encodable</code></p> <p>Abstract base class for patterns.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>Encodable</code></p> <p>Abstract base class for queries.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.limit","title":"<code>limit</code>  <code>property</code> <code>writable</code>","text":"<p>The value of the LIMIT modifier.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.offset","title":"<code>offset</code>  <code>property</code> <code>writable</code>","text":"<p>The value of the OFFSET modifier.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.order_by","title":"<code>order_by</code>  <code>property</code> <code>writable</code>","text":"<p>The value of the ORDER BY modifier.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.ask","title":"<code>ask(limit=None, offset=None, fresh_var_prefix=None, fresh_var_counter=None, deepcopy=True)</code>","text":"<p>Converts query to an ASK query.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Offset.</p> </li> <li> <code>fresh_var_prefix</code>               (<code>_str | None</code>, default:                   <code>None</code> )           \u2013            <p>Prefix of fresh variables.</p> </li> <li> <code>deepcopy</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to deep-copy the common clauses.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AskQuery</code>           \u2013            <p>class:<code>AskQuery</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.begin_filter_not_exists","title":"<code>begin_filter_not_exists()</code>","text":"<p>Pushes FILTER NOT EXISTS graph pattern.</p> <p>Returns:</p> <ul> <li> <code>FilterNotExistsGraphPattern</code>           \u2013            <p>class:<code>FilterNotExistsGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.begin_group","title":"<code>begin_group()</code>","text":"<p>Pushes group graph pattern.</p> <p>Returns:</p> <ul> <li> <code>GroupGraphPattern</code>           \u2013            <p>class:<code>GroupGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.begin_optional","title":"<code>begin_optional()</code>","text":"<p>Pushes OPTIONAL graph pattern.</p> <p>Returns:</p> <ul> <li> <code>OptionalGraphPattern</code>           \u2013            <p>class:<code>OptionalGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.begin_union","title":"<code>begin_union()</code>","text":"<p>Pushes UNION graph pattern.</p> <p>Returns:</p> <ul> <li> <code>UnionGraphPattern</code>           \u2013            <p>class:<code>UnionGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.bind","title":"<code>bind(expression, variable)</code>","text":"<p>Pushes BIND.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>TExpression</code>)           \u2013            <p>Expression.</p> </li> <li> <code>variable</code>               (<code>TVariable</code>)           \u2013            <p>Variable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>class:<code>Query</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.bnode","title":"<code>bnode()</code>  <code>classmethod</code>","text":"<p>Constructs :class:<code>BNode</code>.</p> <p>Returns:</p> <ul> <li> <code>BNode</code>           \u2013            <p>class:<code>BNode</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.clear_user_data","title":"<code>clear_user_data()</code>","text":"<p>Clears user-data attached to query.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.comments","title":"<code>comments()</code>","text":"<p>Constructs comments block.</p> <p>Returns:</p> <ul> <li> <code>CommentsBlock</code>           \u2013            <p>class:<code>CommentsBlock</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.end_filter_not_exists","title":"<code>end_filter_not_exists()</code>","text":"<p>Pops FILTER NOT EXISTS graph pattern.</p> <p>Returns:</p> <ul> <li> <code>FilterNotExistsGraphPattern</code>           \u2013            <p>class:<code>FilterNotExistsGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.end_group","title":"<code>end_group()</code>","text":"<p>Pops group graph pattern.</p> <p>Returns:</p> <ul> <li> <code>GroupGraphPattern</code>           \u2013            <p>class:<code>GroupGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.end_optional","title":"<code>end_optional()</code>","text":"<p>Pops OPTIONAL graph pattern.</p> <p>Returns:</p> <ul> <li> <code>OptionalGraphPattern</code>           \u2013            <p>class:<code>OptionalGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.end_union","title":"<code>end_union()</code>","text":"<p>Pops UNION graph pattern.</p> <p>Returns:</p> <ul> <li> <code>UnionGraphPattern</code>           \u2013            <p>class:<code>UnionGraphPattern</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.filter","title":"<code>filter(expression)</code>","text":"<p>Pushes FILTER.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>TExpression</code>)           \u2013            <p>Expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>class:<code>Query</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.filter_not_exists","title":"<code>filter_not_exists()</code>","text":"<p>Constructs FILTER NOT EXISTS graph pattern.</p> <p>Returns:</p> <ul> <li> <code>FilterNotExistsGraphPattern</code>           \u2013            <p>class:<code>FilterNotExistsGraphPattern</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.fresh_var","title":"<code>fresh_var()</code>","text":"<p>Constructs fresh variable.</p> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>class:<code>Variable</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.fresh_vars","title":"<code>fresh_vars(n)</code>","text":"<p>Constructs one or more fresh variables.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of fresh variables to construct.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>Iterator of :class:<code>Variable</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.get_limit","title":"<code>get_limit()</code>","text":"<p>Gets the value of the LIMIT modifier.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Limit or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.get_offset","title":"<code>get_offset()</code>","text":"<p>Gets the value of the OFFSET modifier.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Offset or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.get_order_by","title":"<code>get_order_by()</code>","text":"<p>Gets the value of the ORDER BY modifier.</p> <p>Returns:</p> <ul> <li> <code>Expression | None</code>           \u2013            <p>Order by expression.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.get_user_data","title":"<code>get_user_data(key)</code>","text":"<p>Gets the user-data value attached to <code>key</code> in query.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>Key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Value or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.group","title":"<code>group()</code>","text":"<p>Constructs group graph pattern.</p> <p>Returns:</p> <ul> <li> <code>GroupGraphPattern</code>           \u2013            <p>class:<code>GroupGraphPattern</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.literal","title":"<code>literal(content, language=None, datatype=None)</code>  <code>classmethod</code>","text":"<p>Constructs :class:<code>Literal</code>.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>TLiteral</code>)           \u2013            <p>Literal content.</p> </li> <li> <code>language</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Literal language.</p> </li> <li> <code>datatype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Literal datatype.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Literal</code>           \u2013            <p>class:<code>Literal</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.named_subquery","title":"<code>named_subquery(name, query)</code>","text":"<p>Constructs a named sub-select block.</p> <p>Returns:</p> <ul> <li> <code>NamedSubSelectBlock</code>           \u2013            <p>class:<code>NamedSubSelectBlock</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.optional","title":"<code>optional()</code>","text":"<p>Constructs OPTIONAL graph pattern.</p> <p>Returns:</p> <ul> <li> <code>OptionalGraphPattern</code>           \u2013            <p>class:<code>OptionalGraphPattern</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.optional_if","title":"<code>optional_if(condition)</code>","text":"<p>Constructs OPTIONAL or graph pattern depending on <code>condition</code>.</p> <p>Parameters:</p> <ul> <li> <code>condition</code>               (<code>bool</code>)           \u2013            <p>Boolean condition.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptionalGraphPattern | GroupGraphPattern</code>           \u2013            <p>class:<code>OptionalGraphPattern</code> if <code>condition</code> is <code>True</code>;</p> </li> <li> <code>OptionalGraphPattern | GroupGraphPattern</code>           \u2013            <p>class:<code>GroupGraphPattern</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.select","title":"<code>select(*variables, distinct=None, reduced=None, limit=None, offset=None, order_by=None, fresh_var_prefix=None, fresh_var_counter=None, deepcopy=True)</code>","text":"<p>Converts query to a SELECT query.</p> <p>Parameters:</p> <ul> <li> <code>variables</code>               (<code>TVariable | TInlineBind</code>, default:                   <code>()</code> )           \u2013            <p>Variables or inline binds.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable distinct modifier.</p> </li> <li> <code>reduced</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable reduced modifier.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Offset.</p> </li> <li> <code>order_by</code>               (<code>TExpression | None</code>, default:                   <code>None</code> )           \u2013            <p>Order-by expression.</p> </li> <li> <code>fresh_var_prefix</code>               (<code>_str | None</code>, default:                   <code>None</code> )           \u2013            <p>Prefix of fresh variables.</p> </li> <li> <code>deepcopy</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to deep-copy the common clauses.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SelectQuery</code>           \u2013            <p>class:<code>SelectQuery</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.set_limit","title":"<code>set_limit(limit)</code>","text":"<p>Sets the value of the LIMIT modifier.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>)           \u2013            <p>Limit or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.set_offset","title":"<code>set_offset(offset)</code>","text":"<p>Sets the value of the OFFSET modifier.</p> <p>Parameters:</p> <ul> <li> <code>offset</code>               (<code>int | None</code>)           \u2013            <p>Offset or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.set_order_by","title":"<code>set_order_by(expression)</code>","text":"<p>Sets the value of the ORDER BY modifier.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>TExpression | None</code>)           \u2013            <p>Expression or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.set_user_data","title":"<code>set_user_data(key, value)</code>","text":"<p>Attaches user-data <code>value</code> to <code>key</code> in query.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>Key.</p> </li> <li> <code>value</code>               (<code>T</code>)           \u2013            <p>Value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p><code>value</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.subquery","title":"<code>subquery(query)</code>","text":"<p>Constructs a sub-select block.</p> <p>Returns:</p> <ul> <li> <code>SubSelectBlock</code>           \u2013            <p>class:<code>SubSelectBlock</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.triples","title":"<code>triples()</code>","text":"<p>Constructs triples block.</p> <p>Returns:</p> <ul> <li> <code>TriplesBlock</code>           \u2013            <p>class:<code>TriplesBlock</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.union","title":"<code>union()</code>","text":"<p>Constructs UNION graph pattern.</p> <p>Returns:</p> <ul> <li> <code>UnionGraphPattern</code>           \u2013            <p>class:<code>UnionGraphPattern</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.unset_user_data","title":"<code>unset_user_data(key)</code>","text":"<p>Detaches user-data value from <code>key</code> in query.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>Key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The detached value or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.uri","title":"<code>uri(content)</code>  <code>classmethod</code>","text":"<p>Constructs :class:<code>URIRef</code>.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>T_URI</code>)           \u2013            <p>URI content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>URIRef</code>           \u2013            <p>class:<code>URIRef</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.values","title":"<code>values(*variables)</code>","text":"<p>Constructs VALUES block</p> <p>Parameters:</p> <ul> <li> <code>variables</code>               (<code>TVariable</code>, default:                   <code>()</code> )           \u2013            <p>Variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ValuesBlock</code>           \u2013            <p>class:<code>ValuesBlock</code> owned by clause.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.var","title":"<code>var(name)</code>  <code>classmethod</code>","text":"<p>Constructs :class:<code>Variable</code>.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>TVariable</code>)           \u2013            <p>Variable name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>class:<code>Variable</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.vars","title":"<code>vars(name, *names)</code>  <code>classmethod</code>","text":"<p>Constructs one or more variables.</p> Parameter <p>name: Variable name. names: Variable names.</p> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>Iterator of :class:<code>Variable</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.where_is_empty","title":"<code>where_is_empty()</code>","text":"<p>Tests whether the WHERE clause of query is empty.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Query.where_is_nonempty","title":"<code>where_is_nonempty()</code>","text":"<p>Tests whether the WHERE clause of query is nonempty.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.RelationalExpression","title":"<code>RelationalExpression</code>","text":"<p>               Bases: <code>BooleanExpression</code></p> <p>Abstract base class for relational expressions.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.STR","title":"<code>STR</code>","text":"<p>               Bases: <code>UnaryBuiltInCall</code></p> <p>The STR built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-str.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.STRDT","title":"<code>STRDT</code>","text":"<p>               Bases: <code>BinaryBuiltInCall</code></p> <p>The STRDT built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-strdt.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.STRLANG","title":"<code>STRLANG</code>","text":"<p>               Bases: <code>BinaryBuiltInCall</code></p> <p>The STRLANG built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-strlang.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.STRSTARTS","title":"<code>STRSTARTS</code>","text":"<p>               Bases: <code>BinaryBuiltInCall</code></p> <p>The STRSTARTS built-in.</p> <p>See https://www.w3.org/TR/sparql11-query/#func-strstarts.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.SelectClause","title":"<code>SelectClause</code>","text":"<p>               Bases: <code>Clause</code></p> <p>SELECT clause.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.SelectQuery","title":"<code>SelectQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>SELECT query.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.SelectQuery.distinct","title":"<code>distinct</code>  <code>property</code> <code>writable</code>","text":"<p>The DISTINCT modifier.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.SelectQuery.reduced","title":"<code>reduced</code>  <code>property</code> <code>writable</code>","text":"<p>The REDUCED modifier.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.SubSelectBlock","title":"<code>SubSelectBlock</code>","text":"<p>               Bases: <code>GraphPattern</code></p> <p>Sub-select block.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Symbol","title":"<code>Symbol</code>","text":"<p>Symbol table.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.TernaryBuiltInCall","title":"<code>TernaryBuiltInCall</code>","text":"<p>               Bases: <code>BuiltInCall</code></p> <p>Abstract base class for 3-ary built-in calls.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.Triple","title":"<code>Triple</code>","text":"<p>               Bases: <code>Pattern</code></p> <p>Triple pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.TriplesBlock","title":"<code>TriplesBlock</code>","text":"<p>               Bases: <code>AtomicGraphPattern</code></p> <p>Triple block.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.URI_Call","title":"<code>URI_Call</code>","text":"<p>               Bases: <code>Call</code></p> <p>URI function call.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.UnaryBuiltInCall","title":"<code>UnaryBuiltInCall</code>","text":"<p>               Bases: <code>BuiltInCall</code></p> <p>Abstract base class for 1-ary built-in calls.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.UnionGraphPattern","title":"<code>UnionGraphPattern</code>","text":"<p>               Bases: <code>CompoundGraphPattern</code></p> <p>UNION graph pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.ValuesBlock","title":"<code>ValuesBlock</code>","text":"<p>               Bases: <code>AtomicGraphPattern</code></p> <p>VALUES block.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.ValuesLine","title":"<code>ValuesLine</code>","text":"<p>               Bases: <code>Pattern</code></p> <p>Values line pattern.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.WhereClause","title":"<code>WhereClause</code>","text":"<p>               Bases: <code>Clause</code></p> <p>WHERE clause.</p>"},{"location":"api/compiler/sparql/builder/#kif_lib.compiler.sparql.builder.ZeroAryBuiltInCall","title":"<code>ZeroAryBuiltInCall</code>","text":"<p>               Bases: <code>BuiltInCall</code></p> <p>Abstract base class for 0-ary built-in calls.</p>"},{"location":"api/compiler/sparql/compiler/","title":"Compiler","text":""},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.Compiler","title":"<code>Compiler</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for compilers.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.Compiler.context","title":"<code>context</code>  <code>property</code>","text":"<p>The current KIF context.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.Compiler.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for compiler errors.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.Compiler.compile","title":"<code>compile()</code>  <code>abstractmethod</code>","text":"<p>Runs the compiler.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Compiler.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.Compiler.get_context","title":"<code>get_context(context=None)</code>","text":"<p>Gets the current KIF context.</p> <p>If <code>context</code> is not <code>None</code>, returns <code>context</code>.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>Context.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler","title":"<code>SPARQL_Compiler</code>","text":"<p>               Bases: <code>Compiler</code></p> <p>Abstract base class for SPARQL compilers.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.debug","title":"<code>debug</code>  <code>property</code>","text":"<p>Whether debugging is enabled.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>The default options of compiler.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.omega","title":"<code>omega</code>  <code>property</code>","text":"<p>The maximum number of disjoint queries to generate.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.q","title":"<code>q</code>  <code>property</code>","text":"<p>The current query (top of query stack).</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.query","title":"<code>query</code>  <code>property</code>","text":"<p>The current query (top of query stack).</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.query_stack","title":"<code>query_stack</code>  <code>property</code>","text":"<p>The compiled query stack.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>SelectQuery</code></p> <p>The type of queries generated by the SPARQL compiler.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.as_qvar","title":"<code>as_qvar(var)</code>  <code>classmethod</code>","text":"<p>Constructs query variable from variable.</p> <p>Parameters:</p> <ul> <li> <code>var</code>               (<code>Variable</code>)           \u2013            <p>Variable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>Query variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.as_qvars","title":"<code>as_qvars(var, *vars)</code>  <code>classmethod</code>","text":"<p>Constructs one or more query variables from variables.</p> <p>Parameters:</p> <ul> <li> <code>var</code>               (<code>Variable</code>)           \u2013            <p>Variable.</p> </li> <li> <code>vars</code>               (<code>Variable</code>, default:                   <code>()</code> )           \u2013            <p>Variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>Iterator of query variables.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.as_safe_qvar","title":"<code>as_safe_qvar(var)</code>  <code>classmethod</code>","text":"<p>Constructs query variable from variable (safe).</p> <p>If variable is not of a primitive type, raises an error.</p> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>Query variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.as_safe_qvars","title":"<code>as_safe_qvars(var, *vars)</code>  <code>classmethod</code>","text":"<p>Constructs one or more query variables from variables (safe).</p> <p>If one of the variables is not of a primitive type, raises an error.</p> <p>Parameters:</p> <ul> <li> <code>var</code>               (<code>Variable</code>)           \u2013            <p>Variable.</p> </li> <li> <code>vars</code>               (<code>Variable</code>, default:                   <code>()</code> )           \u2013            <p>Variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>Iterator of query variables.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.bnode","title":"<code>bnode()</code>  <code>classmethod</code>","text":"<p>Alias of :meth:<code>Query.bnode</code>.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_data_value_var","title":"<code>fresh_data_value_var()</code>","text":"<p>Constructs a fresh data-value variable.</p> <p>Returns:</p> <ul> <li> <code>DataValueVariable</code>           \u2013            <p>Data-value variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_deep_data_value_var","title":"<code>fresh_deep_data_value_var()</code>","text":"<p>Constructs a fresh deep data-value variable.</p> <p>Returns:</p> <ul> <li> <code>DeepDataValueVariable</code>           \u2013            <p>Deep data-value variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_entity_var","title":"<code>fresh_entity_var()</code>","text":"<p>Constructs a fresh entity variable.</p> <p>Returns:</p> <ul> <li> <code>EntityVariable</code>           \u2013            <p>Entity variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_external_id_var","title":"<code>fresh_external_id_var()</code>","text":"<p>Constructs a fresh external-id variable.</p> <p>Returns:</p> <ul> <li> <code>ExternalIdVariable</code>           \u2013            <p>External id variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_iri_var","title":"<code>fresh_iri_var()</code>","text":"<p>Constructs a fresh IRI variable.</p> <p>Returns:</p> <ul> <li> <code>IRI_Variable</code>           \u2013            <p>IRI variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_item_var","title":"<code>fresh_item_var()</code>","text":"<p>Constructs a fresh item variable.</p> <p>Returns:</p> <ul> <li> <code>ItemVariable</code>           \u2013            <p>Item variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_lexeme_var","title":"<code>fresh_lexeme_var()</code>","text":"<p>Constructs a fresh lexeme variable.</p> <p>Returns:</p> <ul> <li> <code>LexemeVariable</code>           \u2013            <p>Lexeme variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_property_var","title":"<code>fresh_property_var()</code>","text":"<p>Constructs a fresh property variable.</p> <p>Returns:</p> <ul> <li> <code>PropertyVariable</code>           \u2013            <p>Property variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_qualifier_record_var","title":"<code>fresh_qualifier_record_var()</code>","text":"<p>Constructs a fresh qualifier record variable.</p> <p>Returns:</p> <ul> <li> <code>QualifierRecordVariable</code>           \u2013            <p>Qualifier record variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_quantity_var","title":"<code>fresh_quantity_var()</code>","text":"<p>Constructs a fresh quantity variable.</p> <p>Returns:</p> <ul> <li> <code>QuantityVariable</code>           \u2013            <p>Quantity variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_qvar","title":"<code>fresh_qvar()</code>","text":"<p>Constructs a fresh query variable.</p> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>Query variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_qvars","title":"<code>fresh_qvars(n)</code>","text":"<p>Constructs one or more fresh query variables.</p> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>Iterator of variables.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_rank_var","title":"<code>fresh_rank_var()</code>","text":"<p>Constructs a fresh rank variable.</p> <p>Returns:</p> <ul> <li> <code>RankVariable</code>           \u2013            <p>Rank variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_reference_record_set_var","title":"<code>fresh_reference_record_set_var()</code>","text":"<p>Constructs a fresh reference record set variable.</p> <p>Returns:</p> <ul> <li> <code>ReferenceRecordSetVariable</code>           \u2013            <p>Reference record set variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_shallow_data_value_var","title":"<code>fresh_shallow_data_value_var()</code>","text":"<p>Constructs a fresh shallow data-value variable.</p> <p>Returns:</p> <ul> <li> <code>ShallowDataValueVariable</code>           \u2013            <p>Shallow data-value variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_string_var","title":"<code>fresh_string_var()</code>","text":"<p>Constructs a fresh string variable.</p> <p>Returns:</p> <ul> <li> <code>StringVariable</code>           \u2013            <p>String variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_text_var","title":"<code>fresh_text_var()</code>","text":"<p>Constructs a fresh text variable.</p> <p>Returns:</p> <ul> <li> <code>TextVariable</code>           \u2013            <p>Text variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_time_var","title":"<code>fresh_time_var()</code>","text":"<p>Constructs a fresh time variable.</p> <p>Returns:</p> <ul> <li> <code>TimeVariable</code>           \u2013            <p>Time variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_var","title":"<code>fresh_var(variable_class)</code>","text":"<p>Constructs a fresh variable of the given class.</p> <p>Parameters:</p> <ul> <li> <code>variable_class</code>               (<code>type[Variable]</code>)           \u2013            <p>Variable class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>Variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.fresh_vars","title":"<code>fresh_vars(variable_class, n)</code>","text":"<p>Constructs one or more fresh variables of the given class.</p> <p>Parameters:</p> <ul> <li> <code>variable_class</code>               (<code>type[Variable]</code>)           \u2013            <p>Variable class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>Iterator of variables.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.get_debug","title":"<code>get_debug()</code>","text":"<p>Gets the debug flag.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Debug flag.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.get_default_options","title":"<code>get_default_options(context=None)</code>","text":"<p>Gets the default options of compiler.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SPARQL_CompilerOptions</code>           \u2013            <p>Compiler options.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.get_omega","title":"<code>get_omega()</code>","text":"<p>Gets the maximum number of disjoint queries to generate.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Maximum number of disjoint queries.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.get_query","title":"<code>get_query()</code>","text":"<p>Gets the current query (top of query stack).</p> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>Query.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.get_query_stack","title":"<code>get_query_stack()</code>","text":"<p>Get the compiled query stack.</p> <p>Returns:</p> <ul> <li> <code>Sequence[Query]</code>           \u2013            <p>Query stack.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.literal","title":"<code>literal(content, language=None, datatype=None)</code>  <code>classmethod</code>","text":"<p>Alias of :meth:<code>Query.literal</code>.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.pop_query","title":"<code>pop_query()</code>","text":"<p>Pops query from query stack.</p> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>The popped query.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.push_query","title":"<code>push_query(query=None)</code>","text":"<p>Pushes query onto query stack.</p> <p>If <code>query</code> is <code>None</code>, pushes an empty query.</p> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>The pushed query.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.qvar","title":"<code>qvar(name)</code>  <code>classmethod</code>","text":"<p>Alias of :meth:<code>Query.var</code>.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.qvars","title":"<code>qvars(var, *vars)</code>  <code>classmethod</code>","text":"<p>Alias of :meth:<code>Query.vars</code>.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_Compiler.uri","title":"<code>uri(content)</code>  <code>classmethod</code>","text":"<p>Alias of :meth:<code>Query.uri</code>.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler","title":"<code>SPARQL_FilterCompiler</code>","text":"<p>               Bases: <code>SPARQL_Compiler</code></p> <p>SPARQL filter compiler</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>The entry associated with current frame.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.filter","title":"<code>filter</code>  <code>property</code>","text":"<p>The (normalized) source filter.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.frame","title":"<code>frame</code>  <code>property</code>","text":"<p>The current frame.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.mapping","title":"<code>mapping</code>  <code>property</code>","text":"<p>The SPARQL mapping.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.pattern","title":"<code>pattern</code>  <code>property</code>","text":"<p>The source pattern.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>The compilation phase associated with the current frame.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.targets","title":"<code>targets</code>  <code>property</code>","text":"<p>The target patterns associated with current frame.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.theta","title":"<code>theta</code>  <code>property</code>","text":"<p>The substitution associated with the current frame.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.Frame","title":"<code>Frame</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Compilation frame (context).</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.Phase","title":"<code>Phase</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Compilation phases.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.Projection","title":"<code>Projection</code>","text":"<p>               Bases: <code>Flag</code></p> <p>Statement projection mask.</p>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.build_query","title":"<code>build_query(query, projection=None, distinct=None, limit=None, offset=None)</code>","text":"<p>Constructs a filter query.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>Query</code>)           \u2013            <p>Query.</p> </li> <li> <code>projection</code>               (<code>Projection | None</code>, default:                   <code>None</code> )           \u2013            <p>Projection mask.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable the distinct modifier.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Offset.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>Filter query.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.build_results","title":"<code>build_results()</code>","text":"<p>Constructs a compilation result builder.</p> <p>Returns:</p> <ul> <li> <code>Callable[[SPARQL_ResultsBinding], Iterable[Theta] | None]</code>           \u2013            <p>A function to convert a binding in SPARQL results into variable</p> </li> <li> <code>Callable[[SPARQL_ResultsBinding], Iterable[Theta] | None]</code>           \u2013            <p>instantiations (thetas).</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_entry","title":"<code>get_entry()</code>","text":"<p>Gets the entry associated with current frame.</p> <p>Returns:</p> <ul> <li> <code>Entry</code>           \u2013            <p>SPARQL mapping entry.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_filter","title":"<code>get_filter()</code>","text":"<p>Gets the (normalized) source filter.</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_frame","title":"<code>get_frame()</code>","text":"<p>Gets the current frame.</p> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            <p>Frame.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_mapping","title":"<code>get_mapping()</code>","text":"<p>Gets the SPARQL mapping.</p> <p>Returns:</p> <ul> <li> <code>SPARQL_Mapping</code>           \u2013            <p>SPARQL mapping.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_pattern","title":"<code>get_pattern()</code>","text":"<p>Gets the source pattern.</p> <p>Returns:</p> <ul> <li> <code>Pattern</code>           \u2013            <p>Pattern.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_phase","title":"<code>get_phase()</code>","text":"<p>Gets the compilation phase associated with the current frame.</p> <p>Returns:</p> <ul> <li> <code>Phase</code>           \u2013            <p>Compilation phase.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_targets","title":"<code>get_targets()</code>","text":"<p>Gets the target patterns associated with current frame.</p> <p>Returns:</p> <ul> <li> <code>Sequence[EntryPattern]</code>           \u2013            <p>Sequence of SPARQL mapping entry patterns.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.get_theta","title":"<code>get_theta()</code>","text":"<p>Gets the substitution associated with the current frame.</p> <p>Returns:</p> <ul> <li> <code>Substitution</code>           \u2013            <p>Substitution.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.is_compiling_filter","title":"<code>is_compiling_filter()</code>","text":"<p>Tests whether compiler is in \"compiling filter\" phase.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.is_compiling_fingerprint","title":"<code>is_compiling_fingerprint()</code>","text":"<p>Tests whether compiler is in \"compiling fingerprint\" phase.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.is_done","title":"<code>is_done()</code>","text":"<p>Tests whether compiler is in \"done\" phase.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.is_ready","title":"<code>is_ready()</code>","text":"<p>Tests whether compiler is in \"ready\" phase.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.pop_frame","title":"<code>pop_frame()</code>","text":"<p>Pops the current compilation frame.</p> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            <p>The popped frame.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.push_frame","title":"<code>push_frame(phase, entry=None, theta=None, targets=None)</code>","text":"<p>Pushes a new compilation frame making it the current frame.</p> <p>phase: Compilation phase. entry: Mapping entry. theta: Substitution. targets: Mapping entry patterns.</p> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            <p>The pushed frame.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.theta_add","title":"<code>theta_add(variable, value)</code>","text":"<p>Adds variable-value pair to the current substitution.</p> <p>Parameters:</p> <ul> <li> <code>variable</code>               (<code>Variable</code>)           \u2013            <p>Variable.</p> </li> <li> <code>value</code>               (<code>T</code>)           \u2013            <p>Value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>Value.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.theta_add_as_qvar","title":"<code>theta_add_as_qvar(variable)</code>","text":"<p>Adds variable-query variable to the current substitution.</p> <p>Parameters:</p> <ul> <li> <code>variable</code>               (<code>Variable</code>)           \u2013            <p>Variable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>Query variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/compiler/#kif_lib.compiler.sparql.SPARQL_FilterCompiler.theta_add_default","title":"<code>theta_add_default(variable, value)</code>","text":"<p>Sets default value for variable in the current substitution.</p> <p>Parameters:</p> <ul> <li> <code>variable</code>               (<code>Variable</code>)           \u2013            <p>Variable.</p> </li> <li> <code>value</code>               (<code>Term | None</code>)           \u2013            <p>Value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            <p>Variable.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/dbpedia/","title":"DBpedia SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/dbpedia/#kif_lib.compiler.sparql.mapping.dbpedia.DBpediaMapping","title":"<code>DBpediaMapping</code>","text":"<p>               Bases: <code>SPARQL_Mapping</code></p> <p>DBpedia SPARQL mapping.</p>"},{"location":"api/compiler/sparql/mapping/dbpedia/#kif_lib.compiler.sparql.mapping.dbpedia.DBpediaMapping.options","title":"<code>options</code>  <code>property</code>","text":"<p>The DBpedia SPARQL mapping options.</p>"},{"location":"api/compiler/sparql/mapping/dbpedia/#kif_lib.compiler.sparql.mapping.dbpedia.DBpediaMapping.get_options","title":"<code>get_options()</code>","text":"<p>Gets the DBpedia SPARQL mapping options.</p> <p>Returns:</p> <ul> <li> <code>DBpediaMappingOptions</code>           \u2013            <p>DBpedia SPARQL mapping options.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/europa/","title":"Europa SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/europa/#kif_lib.compiler.sparql.mapping.europa.EuropaMapping","title":"<code>EuropaMapping</code>","text":"<p>               Bases: <code>SPARQL_Mapping</code></p> <p>Europa (data.europa.eu) SPARQL mapping.</p>"},{"location":"api/compiler/sparql/mapping/europa/#kif_lib.compiler.sparql.mapping.europa.EuropaMapping.options","title":"<code>options</code>  <code>property</code>","text":"<p>The Europa SPARQL mapping options.</p>"},{"location":"api/compiler/sparql/mapping/europa/#kif_lib.compiler.sparql.mapping.europa.EuropaMapping.get_options","title":"<code>get_options()</code>","text":"<p>Gets the Europa SPARQL mapping options.</p> <p>Returns:</p> <ul> <li> <code>EuropaMappingOptions</code>           \u2013            <p>Europa SPARQL mapping options.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/factgrid/","title":"FactGrid SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/factgrid/#kif_lib.compiler.sparql.mapping.factgrid.FactGridMapping","title":"<code>FactGridMapping</code>","text":"<p>               Bases: <code>WikidataMapping</code></p> <p>FactGrid SPARQL mapping.</p>"},{"location":"api/compiler/sparql/mapping/mapping/","title":"SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping","title":"<code>SPARQL_Mapping</code>","text":"<p>               Bases: <code>Sequence[_Entry]</code></p> <p>SPARQL mapping.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.context","title":"<code>context</code>  <code>property</code>","text":"<p>The current KIF context.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.CheckDecimal","title":"<code>CheckDecimal</code>","text":"<p>               Bases: <code>CheckLiteral</code></p> <p>Checks decimal argument.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.CheckInt","title":"<code>CheckInt</code>","text":"<p>               Bases: <code>CheckLiteral</code></p> <p>Checks int argument.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.CheckLiteral","title":"<code>CheckLiteral</code>","text":"<p>               Bases: <code>CheckStr</code></p> <p>Checks literal argument.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.CheckStr","title":"<code>CheckStr</code>","text":"<p>               Bases: <code>EntryCallbackArgProcessor</code></p> <p>Checks str argument.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.CheckURI","title":"<code>CheckURI</code>","text":"<p>               Bases: <code>CheckStr</code></p> <p>Check URI argument.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.Done","title":"<code>Done</code>","text":"<p>               Bases: <code>Signal</code></p> <p>The \"done\" signal.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.EntryCallback","title":"<code>EntryCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>The type of entry callbacks.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.EntryCallbackArgProcessor","title":"<code>EntryCallbackArgProcessor</code>","text":"<p>Entry callback-arg processor.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.EntryCallbackArgProcessorAlias","title":"<code>EntryCallbackArgProcessorAlias</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>The type of callback-arg processor aliases.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.EntryCallbackArgProcessorChain","title":"<code>EntryCallbackArgProcessorChain</code>","text":"<p>               Bases: <code>EntryCallbackArgProcessor</code></p> <p>Entry callback-arg processor chain.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.ResultBuilder","title":"<code>ResultBuilder</code>","text":"<p>Result builder for SPARQL mapping.</p> <p>Parameters:</p> <ul> <li> <code>mapping</code>               (<code>SPARQL_Mapping</code>)           \u2013            <p>SPARQL mapping.</p> </li> <li> <code>compiler</code>               (<code>SPARQL_FilterCompiler</code>)           \u2013            <p>SPARQL compiler.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.ResultBuilder.push","title":"<code>push(binding)</code>","text":"<p>Pushes SPARQL binding into result builder.</p> <p>Parameters:</p> <ul> <li> <code>binding</code>               (<code>SPARQL_ResultsBinding</code>)           \u2013            <p>SPARQL binding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Theta]</code>           \u2013            <p>An iterator of thetas.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.Signal","title":"<code>Signal</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Base class for entry signals.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.Skip","title":"<code>Skip</code>","text":"<p>               Bases: <code>Signal</code></p> <p>The \"skip\" signal.</p>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.build_query","title":"<code>build_query(compiler, query, projection=None, distinct=None, limit=None, offset=None)</code>","text":"<p>Constructs a filter query.</p> <p>Parameters:</p> <ul> <li> <code>compiler</code>               (<code>SPARQL_FilterCompiler</code>)           \u2013            <p>SPARQL compiler.</p> </li> <li> <code>query</code>               (<code>Query</code>)           \u2013            <p>Query.</p> </li> <li> <code>projection</code>               (<code>Projection | None</code>, default:                   <code>None</code> )           \u2013            <p>Projection mask.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable the distinct modifier.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Offset.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Query</code>           \u2013            <p>Filter query.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.build_results","title":"<code>build_results(compiler)</code>","text":"<p>Constructs a compilation result builder.</p> <p>Parameters:</p> <ul> <li> <code>compiler</code>               (<code>SPARQL_FilterCompiler</code>)           \u2013            <p>SPARQL compiler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ResultBuilder</code>           \u2013            <p>Result builder.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.frame_popped","title":"<code>frame_popped(compiler, frame)</code>","text":"<p>Called the current compilation frame is popped.</p> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            <p>The popped frame.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.frame_pushed","title":"<code>frame_pushed(compiler, frame)</code>","text":"<p>Called before a new compilation frame is pushed.</p> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            <p>The frame to be pushed.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.get_context","title":"<code>get_context()</code>","text":"<p>Gets the KIF context of SPARQL mapping.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>Context.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.postamble","title":"<code>postamble(compiler)</code>","text":"<p>Called after compilation ends.</p> <p>Parameters:</p> <ul> <li> <code>compiler</code>               (<code>SPARQL_FilterCompiler</code>)           \u2013            <p>SPARQL compiler.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.preamble","title":"<code>preamble(compiler, sources)</code>","text":"<p>Called before compilation starts.</p> <p>Parameters:</p> <ul> <li> <code>compiler</code>               (<code>SPARQL_FilterCompiler</code>)           \u2013            <p>SPARQL compiler.</p> </li> <li> <code>sources</code>               (<code>Iterable[EntryPattern]</code>)           \u2013            <p>Source patterns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[EntryPattern]</code>           \u2013            <p>Source patterns.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.preamble_entry","title":"<code>preamble_entry(compiler, entry)</code>","text":"<p>Called before entry compilation starts.</p> <p>Parameters:</p> <ul> <li> <code>entry</code>               (<code>Entry</code>)           \u2013            <p>Entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Entry</code>           \u2013            <p>Entry.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/mapping/#kif_lib.compiler.sparql.mapping.SPARQL_Mapping.register","title":"<code>register(patterns, preprocess=None, postprocess=None, defaults=None, priority=None, qualifiers=None, references=None, rank=None)</code>  <code>classmethod</code>","text":"<p>Decorator used to register a new entry into mapping.</p> <p>Parameters:</p> <ul> <li> <code>patterns</code>               (<code>Iterable[EntryTPattern]</code>)           \u2013            <p>Statements, statement templates, or statement variables.</p> </li> <li> <code>preprocess</code>               (<code>EntryCallbackArgProcessorMap | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback-arg pre-processor map.</p> </li> <li> <code>postprocess</code>               (<code>EntryCallbackArgProcessorMap | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback-arg post-processor map.</p> </li> <li> <code>defaults</code>               (<code>EntryCallbackArgDefaultMap | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback-arg default map.</p> </li> <li> <code>priority</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Priority.</p> </li> <li> <code>qualifiers</code>               (<code>TQualifierRecord | None</code>, default:                   <code>None</code> )           \u2013            <p>Qualifiers to be added to statement patterns.</p> </li> <li> <code>references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>References to be added to statement patterns.</p> </li> <li> <code>rank</code>               (<code>TRank | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank to be added to statement patterns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[..., Any]</code>           \u2013            <p>The wrapped callback.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/pubchem/","title":"PubChem SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/pubchem/#kif_lib.compiler.sparql.mapping.pubchem.PubChemMapping","title":"<code>PubChemMapping</code>","text":"<p>               Bases: <code>SPARQL_Mapping</code></p> <p>PubChem SPARQL mapping.</p> <p>Parameters:</p> <ul> <li> <code>normalize_casrn</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to normalize the returned CAS-RNs.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/pubchem/#kif_lib.compiler.sparql.mapping.pubchem.PubChemMapping.options","title":"<code>options</code>  <code>property</code>","text":"<p>The PubChem SPARQL mapping options.</p>"},{"location":"api/compiler/sparql/mapping/pubchem/#kif_lib.compiler.sparql.mapping.pubchem.PubChemMapping.get_options","title":"<code>get_options()</code>","text":"<p>Gets the PubChem SPARQL mapping options.</p> <p>Returns:</p> <ul> <li> <code>PubChemMappingOptions</code>           \u2013            <p>PubChem SPARQL mapping options.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/uniprot/","title":"UniProt SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/uniprot/#kif_lib.compiler.sparql.mapping.uniprot.UniProtMapping","title":"<code>UniProtMapping</code>","text":"<p>               Bases: <code>SPARQL_Mapping</code></p> <p>UniProt SPARQL mapping.</p>"},{"location":"api/compiler/sparql/mapping/uniprot/#kif_lib.compiler.sparql.mapping.uniprot.UniProtMapping.options","title":"<code>options</code>  <code>property</code>","text":"<p>The UniProt SPARQL mapping options.</p>"},{"location":"api/compiler/sparql/mapping/uniprot/#kif_lib.compiler.sparql.mapping.uniprot.UniProtMapping.get_options","title":"<code>get_options()</code>","text":"<p>Gets the UniProt SPARQL mapping options.</p> <p>Returns:</p> <ul> <li> <code>UniProtMappingOptions</code>           \u2013            <p>UniProt SPARQL mapping options.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/wikidata/","title":"Wikidata SPARQL Mapping","text":""},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping","title":"<code>WikidataMapping</code>","text":"<p>               Bases: <code>SPARQL_Mapping</code></p> <p>Wikidata SPARQL mapping.</p> <p>Parameters:</p> <ul> <li> <code>blazegraph</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to target Blazegraph (use named subqueries).</p> </li> <li> <code>strict</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to be strict (assume full Wikidata compatibility).</p> </li> <li> <code>truthy</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Truthy mask to be used in the filter compilation phase.</p> </li> <li> <code>use_schema</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to use the registered property schemas.</p> </li> <li> <code>type</code>               (<code>URI | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Expression for matching :class:<code>TypeProperty</code>.</p> </li> <li> <code>subtype</code>               (<code>URI | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Expression for matching from :class:<code>SubtypeProperty</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.options","title":"<code>options</code>  <code>property</code>","text":"<p>The Wikidata SPARQL mapping options.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.wds","title":"<code>wds</code>  <code>property</code>","text":"<p>The current wds variable.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.CheckDatatype","title":"<code>CheckDatatype</code>","text":"<p>               Bases: <code>EntryCallbackArgProcessor</code></p> <p>Checks whether argument is a datatype value.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.CheckIRI","title":"<code>CheckIRI</code>","text":"<p>               Bases: <code>CheckStr</code></p> <p>Checks whether argument is a IRI content.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.CheckItem","title":"<code>CheckItem</code>","text":"<p>               Bases: <code>CheckURI</code></p> <p>Checks whether argument is an item URI.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.CheckLexeme","title":"<code>CheckLexeme</code>","text":"<p>               Bases: <code>CheckURI</code></p> <p>Checks whether argument is a lexeme URI.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.CheckProperty","title":"<code>CheckProperty</code>","text":"<p>               Bases: <code>CheckURI</code></p> <p>Checks whether argument is a property URI.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.URI_Schema","title":"<code>URI_Schema</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Resolved property schema with URI values.</p>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.get_options","title":"<code>get_options()</code>","text":"<p>Gets the Wikidata SPARQL mapping options.</p> <p>Returns:</p> <ul> <li> <code>WikidataMappingOptions</code>           \u2013            <p>Wikidata SPARQL mapping options.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.get_uri_schema","title":"<code>get_uri_schema(target)</code>","text":"<p>Gets the resolved property URI schema of target.</p> <p>If <code>target</code> cannot be coerced to URI, returns <code>None</code>.</p> <p>If <code>target</code> has no property schema, returns <code>None</code>.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>Any</code>)           \u2013            <p>URI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>URI_Schema | None</code>           \u2013            <p>Resolved URI schema or <code>None</code>.</p> </li> </ul>"},{"location":"api/compiler/sparql/mapping/wikidata/#kif_lib.compiler.sparql.mapping.wikidata.WikidataMapping.get_wds","title":"<code>get_wds()</code>","text":"<p>Gets the current wds variable.</p> <p>Returns:</p> <ul> <li> <code>T_WDS</code>           \u2013            <p>Query variable or blank note.</p> </li> </ul>"},{"location":"api/model/filter/","title":"Filter","text":""},{"location":"api/model/filter/#kif_lib.Filter","title":"<code>Filter</code>","text":"<p>               Bases: <code>KIF_Object</code></p> <p>Criterion for matching statements.</p> <p>A statement matches a filter if:</p> <ul> <li>Its subject matches the filter <code>subject</code>.</li> <li>Its property matches the filter <code>property</code>.</li> <li>Its value (if any) matches the filter <code>value</code>.</li> <li>Its snak type matches the filter <code>snak_mask</code>.</li> <li>Its subject type matches the filter <code>subject_mask</code>.</li> <li>Its property type matches the filter <code>property_mask</code></li> <li>Its value type (if any) matches the filter <code>value_mask</code>.</li> <li>Its rank (if any) matches the filter <code>rank_mask</code>.</li> <li>Its value language (if any) matches the filter <code>language</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Subject fingerprint.</p> </li> <li> <code>property</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Property fingerprint.</p> </li> <li> <code>value</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Value fingerprint.</p> </li> <li> <code>snak_mask</code>               (<code>TSnakMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak mask.</p> </li> <li> <code>subject_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>property_mask</code>               (<code>TPropertyMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Property mask.</p> </li> <li> <code>value_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>rank_mask</code>               (<code>TRankMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank mask.</p> </li> <li> <code>best_ranked</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Best-ranked flag.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>annotated</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Annotated flag.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.DatatypeMask","title":"<code>DatatypeMask</code>","text":"<p>               Bases: <code>Flags</code></p> <p>Mask for concrete datatype classes.</p>"},{"location":"api/model/filter/#kif_lib.Filter.DatatypeMask.match","title":"<code>match(datatype)</code>","text":"<p>Tests whether datatype mask matches <code>datatype</code>.</p> <p>Parameters:</p> <ul> <li> <code>datatype</code>               (<code>TDatatype</code>)           \u2013            <p>Datatype.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.PropertyMask","title":"<code>PropertyMask</code>","text":"<p>               Bases: <code>Flags</code></p> <p>Mask for concrete property classes.</p>"},{"location":"api/model/filter/#kif_lib.Filter.PropertyMask.match","title":"<code>match(property)</code>","text":"<p>Tests whether property mask matches <code>property</code>.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>TProperty</code>)           \u2013            <p>Property.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.RankMask","title":"<code>RankMask</code>","text":"<p>               Bases: <code>Flags</code></p> <p>Mask for concrete rank classes.</p>"},{"location":"api/model/filter/#kif_lib.Filter.RankMask.match","title":"<code>match(rank)</code>","text":"<p>Tests whether rank mask matches <code>rank</code>.</p> <p>Parameters:</p> <ul> <li> <code>rank</code>               (<code>TRank</code>)           \u2013            <p>Rank.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.SnakMask","title":"<code>SnakMask</code>","text":"<p>               Bases: <code>Flags</code></p> <p>Mask for concrete snak classes.</p>"},{"location":"api/model/filter/#kif_lib.Filter.SnakMask.match","title":"<code>match(snak)</code>","text":"<p>Tests whether snak mask matches <code>snak</code>.</p> <p>Parameters:</p> <ul> <li> <code>snak</code>               (<code>TSnak</code>)           \u2013            <p>Snak.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.annotated","title":"<code>annotated()</code>","text":"<p>The annotated flag of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.best_ranked","title":"<code>best_ranked()</code>","text":"<p>The best-ranked flag of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.combine","title":"<code>combine(*others, operator='and')</code>","text":"<p>Combines filter with <code>others</code>.</p> <p>The <code>operator</code> (\"and\" or \"or\") determines the logical operator to be used to combine the filters.</p> <p>Parameters:</p> <ul> <li> <code>others</code>               (<code>Filter</code>, default:                   <code>()</code> )           \u2013            <p>Filters.</p> </li> <li> <code>operator</code>               (<code>Literal['and', 'or']</code>, default:                   <code>'and'</code> )           \u2013            <p>Logical operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.from_snak","title":"<code>from_snak(subject=None, snak=None)</code>  <code>classmethod</code>","text":"<p>Creates filter from snak.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Entity fingerprint.</p> </li> <li> <code>snak</code>               (<code>Snak | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.from_statement","title":"<code>from_statement(stmt)</code>  <code>classmethod</code>","text":"<p>Creates filter from statement.</p> <p>Parameters:</p> <ul> <li> <code>stmt</code>               (<code>Statement</code>)           \u2013            <p>Statement.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_annotated","title":"<code>get_annotated()</code>","text":"<p>Gets the annotated flag of filter.</p> <p>Whether to fetch statement annotations.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Annotated flag.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_best_ranked","title":"<code>get_best_ranked()</code>","text":"<p>Gets the best-ranked flag of filter.</p> <p>Whether to match best-ranked statements.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Annotated flag.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_language","title":"<code>get_language()</code>","text":"<p>Gets the language criterion of filter.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Language.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_property","title":"<code>get_property()</code>","text":"<p>Gets the property criterion of filter.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_property_mask","title":"<code>get_property_mask()</code>","text":"<p>Gets the property mask of filter.</p> <p>Returns:</p> <ul> <li> <code>PropertyMask</code>           \u2013            <p>Property mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_rank_mask","title":"<code>get_rank_mask()</code>","text":"<p>Gets the rank mask of filter.</p> <p>Returns:</p> <ul> <li> <code>RankMask</code>           \u2013            <p>Rank mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_snak_mask","title":"<code>get_snak_mask()</code>","text":"<p>Gets the snak mask of filter.</p> <p>Returns:</p> <ul> <li> <code>SnakMask</code>           \u2013            <p>Snak mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_subject","title":"<code>get_subject()</code>","text":"<p>Gets the subject criterion of filter.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_subject_mask","title":"<code>get_subject_mask()</code>","text":"<p>Gets the subject mask of filter.</p> <p>Returns:</p> <ul> <li> <code>DatatypeMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_value","title":"<code>get_value()</code>","text":"<p>Gets the value criterion of filter.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.get_value_mask","title":"<code>get_value_mask()</code>","text":"<p>Gets the value mask of filter.</p> <p>Returns:</p> <ul> <li> <code>DatatypeMask</code>           \u2013            <p>Value mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.is_empty","title":"<code>is_empty()</code>","text":"<p>Tests whether filter is empty.</p> <p>An empty filter matches nothing.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.is_full","title":"<code>is_full()</code>","text":"<p>Tests whether filter is full.</p> <p>A full filter matches anything.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.is_nonempty","title":"<code>is_nonempty()</code>","text":"<p>Tests whether filter is non-empty.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.is_nonfull","title":"<code>is_nonfull()</code>","text":"<p>Tests whether filter is non-full.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.language","title":"<code>language()</code>","text":"<p>The language criterion of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.match","title":"<code>match(stmt)</code>","text":"<p>Tests whether filter shallow-matches statement.</p> <p>Parameters:</p> <ul> <li> <code>stmt</code>               (<code>TStatement</code>)           \u2013            <p>Statement.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.normalize","title":"<code>normalize()</code>","text":"<p>Reduces filter to a normal form.</p> <p>Normalizes the fingerprint expressions in filter.</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Filter.property","title":"<code>property()</code>","text":"<p>The property criterion of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.property_mask","title":"<code>property_mask()</code>","text":"<p>The property mask of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.rank_mask","title":"<code>rank_mask()</code>","text":"<p>The rank mask of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.snak_mask","title":"<code>snak_mask()</code>","text":"<p>The snak mask of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.subject","title":"<code>subject()</code>","text":"<p>The subject criterion of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.subject_mask","title":"<code>subject_mask()</code>","text":"<p>The subject mask of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.value","title":"<code>value()</code>","text":"<p>The value criterion of filter.</p>"},{"location":"api/model/filter/#kif_lib.Filter.value_mask","title":"<code>value_mask()</code>","text":"<p>The value mask of filter.</p>"},{"location":"api/model/filter/#kif_lib.Fingerprint","title":"<code>Fingerprint</code>","text":"<p>               Bases: <code>KIF_Object</code></p> <p>Abstract base class for fingerprint expressions.</p>"},{"location":"api/model/filter/#kif_lib.Fingerprint.datatype_mask","title":"<code>datatype_mask</code>  <code>property</code>","text":"<p>The datatypes shallow-matched by fingerprint.</p>"},{"location":"api/model/filter/#kif_lib.Fingerprint.range_datatype_mask","title":"<code>range_datatype_mask</code>  <code>property</code>","text":"<p>The datatypes shallow-matched by the range of fingerprint.</p>"},{"location":"api/model/filter/#kif_lib.Fingerprint.get_datatype_mask","title":"<code>get_datatype_mask()</code>","text":"<p>Gets the datatypes shallow-matched by fingerprint.</p> <p>Returns:</p> <ul> <li> <code>DatatypeMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Fingerprint.get_range_datatype_mask","title":"<code>get_range_datatype_mask()</code>","text":"<p>Gets the datatypes shallow-matched by the range of fingerprint.</p> <p>Returns:</p> <ul> <li> <code>DatatypeMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Fingerprint.is_empty","title":"<code>is_empty()</code>","text":"<p>Tests whether fingerprint is empty (matches nothing).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Fingerprint.is_full","title":"<code>is_full()</code>","text":"<p>Tests whether fingerprint is full (matches anything).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Fingerprint.match","title":"<code>match(value)</code>","text":"<p>Tests whether fingerprint shallow-matches value.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>TValue</code>)           \u2013            <p>Value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.Fingerprint.normalize","title":"<code>normalize(datatype_mask=None)</code>","text":"<p>Reduces fingerprint to a normal form.</p> <p>If <code>datatype_mask</code> is given, ensures that the resulting fingerprint matches only values with a datatype in <code>datatype_mask</code>.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Normal fingerprint.</p> </li> </ul>"},{"location":"api/model/filter/#kif_lib.And","title":"<code>And = AndFingerprint</code>  <code>module-attribute</code>","text":""},{"location":"api/model/filter/#kif_lib.Or","title":"<code>Or = OrFingerprint</code>  <code>module-attribute</code>","text":""},{"location":"api/model/kif_object/","title":"KIF Object","text":""},{"location":"api/model/kif_object/#kif_lib.model.object.Object","title":"<code>Object</code>","text":"<p>               Bases: <code>Generic[Unpack[Ts]]</code></p> <p>Abstract base class for syntactical objects.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.args","title":"<code>args</code>  <code>property</code>","text":"<p>The arguments of object.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.digest","title":"<code>digest</code>  <code>property</code>","text":"<p>The digest of object.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for errors.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.KeepType","title":"<code>KeepType</code>","text":"<p>Type for the sentinel of :meth:<code>Object.replace</code>.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.MissingDependency","title":"<code>MissingDependency</code>","text":"<p>               Bases: <code>ImportError</code></p> <p>Missing dependency.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.NilType","title":"<code>NilType</code>","text":"<p>Type for absence of value distinct from <code>NoneType</code>.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.ShouldNotGetHere","title":"<code>ShouldNotGetHere</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Should not get here.</p>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.check","title":"<code>check(arg, function=None, name=None, position=None)</code>  <code>classmethod</code>","text":"<p>Coerces <code>arg</code> into an instance of this class.</p> <p>If <code>arg</code> cannot be coerced, raises an error.</p> <p>Parameters:</p> <ul> <li> <code>arg</code>               (<code>Any</code>)           \u2013            <p>Value.</p> </li> <li> <code>function</code>               (<code>TLoc | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Argument name.</p> </li> <li> <code>position</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Argument position.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.check_optional","title":"<code>check_optional(arg, default=None, function=None, name=None, position=None)</code>  <code>classmethod</code>","text":"<p>Coerces optional <code>arg</code> into an instance of this class.</p> <p>If <code>arg</code> cannot be coerced, raises an error.</p> <p>If <code>arg</code> is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>arg</code>               (<code>Any | None</code>)           \u2013            <p>Value.</p> </li> <li> <code>default</code>               (<code>Any | None</code>, default:                   <code>None</code> )           \u2013            <p>Default value.</p> </li> <li> <code>function</code>               (<code>TLoc | None</code>, default:                   <code>None</code> )           \u2013            <p>Function or function name.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Argument name.</p> </li> <li> <code>position</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Argument position.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object or <code>default</code>.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.copy","title":"<code>copy()</code>","text":"<p>Makes a shallow copy of object.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A shallow copy of object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.deepcopy","title":"<code>deepcopy(memo=None)</code>","text":"<p>Makes a deep copy of object.</p> <p>Parameters:</p> <ul> <li> <code>memo</code>               (<code>dict[Any, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of objects already copied.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A deep copy of object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.dump","title":"<code>dump(stream, format=None, **kwargs)</code>","text":"<p>Encodes object and writes the result to <code>stream</code>.</p> <p>Parameters:</p> <ul> <li> <code>stream</code>               (<code>IO[Any]</code>)           \u2013            <p>A <code>.write()</code>-supporting file-like object.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Encoding format.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.dumps","title":"<code>dumps(format=None, **kwargs)</code>","text":"<p>Encodes object and returns the resulting string.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Encoding format.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.from_ast","title":"<code>from_ast(ast)</code>  <code>classmethod</code>","text":"<p>Converts abstract syntax tree to object.</p> <p>Parameters:</p> <ul> <li> <code>ast</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>Abstract syntax tree.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.from_json","title":"<code>from_json(input, **kwargs)</code>  <code>classmethod</code>","text":"<p>Decodes string using JSON decoder.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>Input string.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.from_repr","title":"<code>from_repr(input, **kwargs)</code>  <code>classmethod</code>","text":"<p>Decodes string using repr decoder.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>Input string.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.from_sexp","title":"<code>from_sexp(input, **kwargs)</code>  <code>classmethod</code>","text":"<p>Decodes string using S-expression decoder.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>Input string.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.get","title":"<code>get(i, default=None)</code>","text":"<p>Gets the value of the <code>i</code>-th argument of object (origin is 0).</p> <p>If argument's value is <code>None</code>, returns <code>default</code>.</p> <p>Returns:</p> <ul> <li> <code>Any | None</code>           \u2013            <p>Argument's value.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.get_args","title":"<code>get_args()</code>","text":"<p>Gets the arguments of object.</p> <p>Returns:</p> <ul> <li> <code>tuple[Unpack[Ts]]</code>           \u2013            <p>Arguments.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.get_digest","title":"<code>get_digest()</code>","text":"<p>Gets the digest of object.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Digest.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.load","title":"<code>load(stream, format=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Decodes <code>stream</code> and returns the resulting object.</p> <p>Parameters:</p> <ul> <li> <code>stream</code>               (<code>IO[Any]</code>)           \u2013            <p>A <code>.read()</code>-supporting file-like object.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Decoding format.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.loads","title":"<code>loads(input, format=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Decodes string and returns the resulting object.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>str</code>)           \u2013            <p>String.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Decoding format.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.replace","title":"<code>replace(*args, **kwargs)</code>","text":"<p>Shallow-copies object overwriting its arguments.</p> <p>If argument is :class:<code>Object.KEEP</code> in <code>args</code>, keeps the value of the corresponding argument in the resulting object.</p> <p>Parameters:</p> <ul> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Arguments.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments (ignored).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A shallow copy of object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.test","title":"<code>test(arg)</code>  <code>classmethod</code>","text":"<p>Tests whether <code>arg</code> is an instance of this class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.to_ast","title":"<code>to_ast()</code>","text":"<p>Converts object to abstract syntax tree.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Dictionary.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Encodes object using JSON encoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.to_repr","title":"<code>to_repr(**kwargs)</code>","text":"<p>Encodes object using repr encoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.model.object.Object.to_sexp","title":"<code>to_sexp(**kwargs)</code>","text":"<p>Encodes object using S-expression encoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object","title":"<code>KIF_Object</code>","text":"<p>               Bases: <code>Object[Unpack[Ts]]</code></p> <p>Abstract base class for KIF objects.</p>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.context","title":"<code>context</code>  <code>property</code>","text":"<p>The current KIF context.</p>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.from_sparql","title":"<code>from_sparql(s, **kwargs)</code>  <code>classmethod</code>","text":"<p>Decodes string using SPARQL decoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options to SPARQL decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>KIF object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`DecoderError`</code>             \u2013            <p>Decoder error.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.get_context","title":"<code>get_context(context=None)</code>  <code>classmethod</code>","text":"<p>Gets the current KIF context.</p> <p>If <code>context</code> is not <code>None</code>, returns <code>context</code>.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>Context.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.substitute","title":"<code>substitute(sigma)</code>","text":"<p>Applies substitution <code>sigma</code> to KIF object's arguments.</p> <p>Parameters:</p> <ul> <li> <code>sigma</code>               (<code>Mapping[Any, Any] | Callable[[Any], Any]</code>)           \u2013            <p>Substitution.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>KIF object.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.to_dot","title":"<code>to_dot(**kwargs)</code>","text":"<p>Encodes object using Dot encoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options to Dot encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`EncoderError`</code>             \u2013            <p>Encoder error.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.to_markdown","title":"<code>to_markdown(**kwargs)</code>","text":"<p>Encodes object using Markdown encoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options to Markdown encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`EncoderError`</code>             \u2013            <p>Encoder error.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.to_rdf","title":"<code>to_rdf(**kwargs)</code>","text":"<p>Encodes object using RDF encoder.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options to RDF encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`EncoderError`</code>             \u2013            <p>Encoder error.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.KIF_Object.traverse","title":"<code>traverse(filter=None, visit=None)</code>","text":"<p>Traverses KIF object-tree recursively.</p> <p>Parameters:</p> <ul> <li> <code>filter</code>               (<code>Callable[[Any], bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Predicate indicating KIF objects or values to yield.</p> </li> <li> <code>visit</code>               (<code>Callable[[Any], bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Predicate indicating KIF objects to visit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Any]</code>           \u2013            <p>An iterator of KIF objects and values.</p> </li> </ul>"},{"location":"api/model/kif_object/#kif_lib.Error","title":"<code>Error = object.Object.Error</code>  <code>module-attribute</code>","text":""},{"location":"api/model/collection/graph/","title":"Graph","text":""},{"location":"api/model/collection/graph/#kif_lib.Graph","title":"<code>Graph</code>","text":"<p>               Bases: <code>ClosedTermSet[Statement]</code></p> <p>Graph (set of statements).</p> <p>Parameters:</p> <ul> <li> <code>statements</code>               (<code>Statement</code>, default:                   <code>()</code> )           \u2013            <p>Statements.</p> </li> </ul>"},{"location":"api/model/collection/graph/#kif_lib.Graph.to_graphviz","title":"<code>to_graphviz()</code>","text":"<p>Converts graph to a Graphviz's graph.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Graphviz graph.</p> </li> </ul>"},{"location":"api/model/collection/pair/","title":"Pair","text":""},{"location":"api/model/collection/pair/#kif_lib.ClosedTermPair","title":"<code>ClosedTermPair</code>","text":"<p>               Bases: <code>ClosedTerm[TL, TR]</code></p> <p>Pair of closed terms.</p>"},{"location":"api/model/collection/pair/#kif_lib.ClosedTermPair.left","title":"<code>left</code>  <code>property</code>","text":"<p>The left component of the pair.</p>"},{"location":"api/model/collection/pair/#kif_lib.ClosedTermPair.right","title":"<code>right</code>  <code>property</code>","text":"<p>The right component of the pair.</p>"},{"location":"api/model/collection/pair/#kif_lib.ClosedTermPair.get_left","title":"<code>get_left()</code>","text":"<p>Gets the left component of the pair.</p> <p>Returns:</p> <ul> <li> <code>TL</code>           \u2013            <p>Closed term.</p> </li> </ul>"},{"location":"api/model/collection/pair/#kif_lib.ClosedTermPair.get_right","title":"<code>get_right()</code>","text":"<p>Gets the right component of the pair.</p> <p>Returns:</p> <ul> <li> <code>TR</code>           \u2013            <p>Closed term.</p> </li> </ul>"},{"location":"api/model/collection/pair/#kif_lib.ValuePair","title":"<code>ValuePair</code>","text":"<p>               Bases: <code>ClosedTermPair[TL, TR]</code></p> <p>Value pair.</p> <p>Parameters:</p> <ul> <li> <code>left</code>               (<code>TL</code>)           \u2013            <p>Value.</p> </li> <li> <code>right</code>               (<code>TR</code>)           \u2013            <p>Value.</p> </li> </ul>"},{"location":"api/model/collection/set/","title":"Set","text":""},{"location":"api/model/collection/set/#kif_lib.ClosedTermSet","title":"<code>ClosedTermSet</code>","text":"<p>               Bases: <code>ClosedTerm</code>, <code>Sequence[T]</code></p> <p>Set of closed terms.</p>"},{"location":"api/model/collection/set/#kif_lib.ClosedTermSet.intersection","title":"<code>intersection(*others)</code>","text":"<p>Computes the intersection of self and <code>others</code>.</p> <p>Parameters:</p> <ul> <li> <code>others</code>               (<code>Self</code>, default:                   <code>()</code> )           \u2013            <p>Closed-term sets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Closed-term set.</p> </li> </ul>"},{"location":"api/model/collection/set/#kif_lib.ClosedTermSet.issubset","title":"<code>issubset(other)</code>","text":"<p>Tests whether self is a subset of <code>other</code>.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Self</code>)           \u2013            <p>Closed-term set.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/collection/set/#kif_lib.ClosedTermSet.issuperset","title":"<code>issuperset(other)</code>","text":"<p>Tests whether self is a superset of <code>other</code>.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Self</code>)           \u2013            <p>Closed-term set.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/collection/set/#kif_lib.ClosedTermSet.union","title":"<code>union(*others)</code>","text":"<p>Computes the union of self and <code>others</code>.</p> <p>Parameters:</p> <ul> <li> <code>others</code>               (<code>Self</code>, default:                   <code>()</code> )           \u2013            <p>Closed-term sets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Closed-term set.</p> </li> </ul>"},{"location":"api/model/collection/set/#kif_lib.SnakSet","title":"<code>SnakSet</code>","text":"<p>               Bases: <code>ClosedTermSet[T]</code></p> <p>Set of snaks.</p> <p>Parameters:</p> <ul> <li> <code>snaks</code>               (<code>Snak</code>, default:                   <code>()</code> )           \u2013            <p>Snaks.</p> </li> </ul>"},{"location":"api/model/snak/no_value_snak/","title":"No Value Snak","text":""},{"location":"api/model/snak/no_value_snak/#kif_lib.NoValueSnak","title":"<code>NoValueSnak</code>","text":"<p>               Bases: <code>Snak</code></p> <p>No-value snak.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>VTProperty</code>)           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/model/snak/snak/","title":"Snak","text":""},{"location":"api/model/snak/snak/#kif_lib.Snak","title":"<code>Snak</code>","text":"<p>               Bases: <code>ClosedTerm[Property, Unpack[Ts]]</code></p> <p>Abstract base class for snaks.</p>"},{"location":"api/model/snak/snak/#kif_lib.Snak.get_property","title":"<code>get_property()</code>","text":"<p>Gets the property of snak.</p> <p>Returns:</p> <ul> <li> <code>Property</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/model/snak/snak/#kif_lib.Snak.property","title":"<code>property()</code>","text":"<p>The property of snak.</p>"},{"location":"api/model/snak/some_value_snak/","title":"Some Value Snak","text":""},{"location":"api/model/snak/some_value_snak/#kif_lib.SomeValueSnak","title":"<code>SomeValueSnak</code>","text":"<p>               Bases: <code>Snak</code></p> <p>Some-value snak.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>VTProperty</code>)           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/model/snak/value_snak/","title":"Value Snak","text":""},{"location":"api/model/snak/value_snak/#kif_lib.ValueSnak","title":"<code>ValueSnak</code>","text":"<p>               Bases: <code>Snak[Value]</code></p> <p>Value snak.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>VTProperty</code>)           \u2013            <p>Property.</p> </li> <li> <code>value</code>               (<code>VTValue</code>)           \u2013            <p>Value.</p> </li> </ul>"},{"location":"api/model/snak/value_snak/#kif_lib.ValueSnak.value","title":"<code>value</code>  <code>property</code>","text":"<p>The value of value snak.</p>"},{"location":"api/model/snak/value_snak/#kif_lib.ValueSnak.get_value","title":"<code>get_value()</code>","text":"<p>Gets the value of value snak.</p> <p>Returns:</p> <ul> <li> <code>Value</code>           \u2013            <p>Value.</p> </li> </ul>"},{"location":"api/model/statement/annotated_statement/","title":"Annotated Statement","text":""},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement","title":"<code>AnnotatedStatement</code>","text":"<p>               Bases: <code>Statement[QualifierRecord, ReferenceRecordSet, Rank]</code></p> <p>Annotated statement.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>VTEntity</code>)           \u2013            <p>Entity.</p> </li> <li> <code>snak</code>               (<code>VTSnak</code>)           \u2013            <p>Snak.</p> </li> <li> <code>qualifiers</code>               (<code>VTQualifierRecord | None</code>, default:                   <code>None</code> )           \u2013            <p>Qualifier record.</p> </li> <li> <code>references</code>               (<code>VTReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Reference record set.</p> </li> <li> <code>rank</code>               (<code>VTRank | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank.</p> </li> </ul>"},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement.qualifiers","title":"<code>qualifiers</code>  <code>property</code>","text":"<p>The qualifiers of annotated statement.</p>"},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement.rank","title":"<code>rank</code>  <code>property</code>","text":"<p>The rank of annotated statement.</p>"},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement.references","title":"<code>references</code>  <code>property</code>","text":"<p>The references of annotated statement.</p>"},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement.get_qualifiers","title":"<code>get_qualifiers()</code>","text":"<p>Gets the qualifiers of annotated statement.</p> <p>Returns:</p> <ul> <li> <code>QualifierRecord</code>           \u2013            <p>Qualifier record.</p> </li> </ul>"},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement.get_rank","title":"<code>get_rank()</code>","text":"<p>Gets the rank of annotated statement.</p> <p>Returns:</p> <ul> <li> <code>Rank</code>           \u2013            <p>Rank.</p> </li> </ul>"},{"location":"api/model/statement/annotated_statement/#kif_lib.AnnotatedStatement.get_references","title":"<code>get_references()</code>","text":"<p>Gets the references of annotated statement.</p> <p>Returns:</p> <ul> <li> <code>ReferenceRecordSet</code>           \u2013            <p>Reference record set.</p> </li> </ul>"},{"location":"api/model/statement/statement/","title":"Statement","text":""},{"location":"api/model/statement/statement/#kif_lib.Statement","title":"<code>Statement</code>","text":"<p>               Bases: <code>ClosedTerm[Entity, Snak, Unpack[Ts]]</code></p> <p>Statement.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>VTEntity</code>)           \u2013            <p>Entity.</p> </li> <li> <code>snak</code>               (<code>VTSnak</code>)           \u2013            <p>Snak.</p> </li> </ul>"},{"location":"api/model/statement/statement/#kif_lib.Statement.claim","title":"<code>claim</code>  <code>property</code>","text":"<p>The claim of statement.</p>"},{"location":"api/model/statement/statement/#kif_lib.Statement.snak","title":"<code>snak</code>  <code>property</code>","text":"<p>The snak of statement.</p>"},{"location":"api/model/statement/statement/#kif_lib.Statement.subject","title":"<code>subject</code>  <code>property</code>","text":"<p>The subject of statement.</p>"},{"location":"api/model/statement/statement/#kif_lib.Statement.annotate","title":"<code>annotate(qualifiers=None, references=None, rank=None, replace=False)</code>","text":"<p>Annotates statement.</p> <p>Parameters:</p> <ul> <li> <code>qualifiers</code>               (<code>VTQualifierRecord | None</code>, default:                   <code>None</code> )           \u2013            <p>Qualifier record.</p> </li> <li> <code>references</code>               (<code>VTReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Reference record set.</p> </li> <li> <code>rank</code>               (<code>VTRank | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank.</p> </li> <li> <code>replace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to replace existing annotations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AnnotatedStatement</code>           \u2013            <p>Annotated statement.</p> </li> </ul>"},{"location":"api/model/statement/statement/#kif_lib.Statement.get_claim","title":"<code>get_claim()</code>","text":"<p>Gets the claim of statement.</p> <p>Returns:</p> <ul> <li> <code>tuple[Entity, Snak]</code>           \u2013            <p>Statement claim: subject, snak.</p> </li> </ul>"},{"location":"api/model/statement/statement/#kif_lib.Statement.get_snak","title":"<code>get_snak()</code>","text":"<p>Gets the snak of statement.</p> <p>Returns:</p> <ul> <li> <code>Snak</code>           \u2013            <p>Snak.</p> </li> </ul>"},{"location":"api/model/statement/statement/#kif_lib.Statement.get_subject","title":"<code>get_subject()</code>","text":"<p>Gets the subject of statement.</p> <p>Returns:</p> <ul> <li> <code>Entity</code>           \u2013            <p>Subject.</p> </li> </ul>"},{"location":"api/model/statement/statement/#kif_lib.Statement.unannotate","title":"<code>unannotate()</code>","text":"<p>Unannotates statement.</p> <p>Returns:</p> <ul> <li> <code>Statement</code>           \u2013            <p>Unannotated statement.</p> </li> </ul>"},{"location":"api/model/statement_annotations/qualifier_record/","title":"Qualifier Record","text":""},{"location":"api/model/statement_annotations/qualifier_record/#kif_lib.QualifierRecord","title":"<code>QualifierRecord</code>","text":"<p>               Bases: <code>SnakSet</code></p> <p>Qualifier record (set of snaks).</p> <p>Parameters:</p> <ul> <li> <code>snaks</code>               (<code>Snak</code>, default:                   <code>()</code> )           \u2013            <p>Snaks.</p> </li> </ul>"},{"location":"api/model/statement_annotations/rank/","title":"Rank","text":""},{"location":"api/model/statement_annotations/rank/#kif_lib.Rank","title":"<code>Rank</code>","text":"<p>               Bases: <code>ClosedTerm</code></p> <p>Abstract base class for statement ranks.</p>"},{"location":"api/model/statement_annotations/rank/#kif_lib.DeprecatedRank","title":"<code>DeprecatedRank</code>","text":"<p>               Bases: <code>Rank</code></p> <p>Unreliable information.</p>"},{"location":"api/model/statement_annotations/rank/#kif_lib.NormalRank","title":"<code>NormalRank</code>","text":"<p>               Bases: <code>Rank</code></p> <p>Complementary information.</p>"},{"location":"api/model/statement_annotations/rank/#kif_lib.PreferredRank","title":"<code>PreferredRank</code>","text":"<p>               Bases: <code>Rank</code></p> <p>Most important information.</p>"},{"location":"api/model/statement_annotations/reference_record/","title":"Reference Record","text":""},{"location":"api/model/statement_annotations/reference_record/#kif_lib.ReferenceRecord","title":"<code>ReferenceRecord</code>","text":"<p>               Bases: <code>SnakSet</code></p> <p>Reference record (set of snaks).</p> <p>Parameters:</p> <ul> <li> <code>snaks</code>               (<code>Snak</code>, default:                   <code>()</code> )           \u2013            <p>Snaks.</p> </li> </ul>"},{"location":"api/model/statement_annotations/reference_record/#kif_lib.ReferenceRecordSet","title":"<code>ReferenceRecordSet</code>","text":"<p>               Bases: <code>ClosedTermSet[ReferenceRecord]</code></p> <p>Set of reference records.</p> <p>Parameters:</p> <ul> <li> <code>reference_records</code>               (<code>TReferenceRecord</code>, default:                   <code>()</code> )           \u2013            <p>Reference records.</p> </li> </ul>"},{"location":"api/model/term/closed_term/","title":"Closed Term","text":""},{"location":"api/model/term/closed_term/#kif_lib.ClosedTerm","title":"<code>ClosedTerm</code>","text":"<p>               Bases: <code>Term[Unpack[Ts]]</code></p> <p>Abstract base class for closed (ground) terms.</p>"},{"location":"api/model/term/term/","title":"Term","text":""},{"location":"api/model/term/term/#kif_lib.Term","title":"<code>Term</code>","text":"<p>               Bases: <code>KIF_Object[Unpack[Ts]]</code></p> <p>Abstract base class for terms.</p>"},{"location":"api/model/term/term/#kif_lib.Term.variables","title":"<code>variables</code>  <code>property</code>","text":"<p>The set of variables occurring in term.</p>"},{"location":"api/model/term/term/#kif_lib.Term.InstantiationError","title":"<code>InstantiationError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Bad instantiation attempt.</p>"},{"location":"api/model/term/term/#kif_lib.Term.generalize","title":"<code>generalize(exclude=(), rename=None, prefix=None)</code>","text":"<p>Replaces <code>None</code> values occurring in term by fresh variables.</p> <p>Picks name variants not occurring in <code>exclude</code>.</p> <p>Uses <code>rename</code> (if given) to generate name variants.</p> <p>Uses <code>prefix</code> (if given) as prefix for name variants.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Iterable[Term | str]</code>, default:                   <code>()</code> )           \u2013            <p>Name variant exclusion list.</p> </li> <li> <code>rename</code>               (<code>Callable[[str], Iterator[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Name variant generator.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name variant prefix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Term.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.get_variables","title":"<code>get_variables()</code>","text":"<p>Gets the set of variables occurring in term.</p> <p>Returns:</p> <ul> <li> <code>Set[Variable]</code>           \u2013            <p>Set of variables.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.instantiate","title":"<code>instantiate(theta, coerce=True, strict=False)</code>","text":"<p>Applies variable instantiation <code>theta</code> to term.</p> <p>Parameters:</p> <ul> <li> <code>theta</code>               (<code>Theta</code>)           \u2013            <p>Variable instantiation.</p> </li> <li> <code>coerce</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to consider coercible variables equal.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to adopt stricter coercion rules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Term | None</code>           \u2013            <p>Term or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.is_closed","title":"<code>is_closed(arg)</code>  <code>classmethod</code>","text":"<p>Tests whether argument is a closed term.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.is_open","title":"<code>is_open(arg)</code>  <code>classmethod</code>","text":"<p>Tests whether argument is an open term.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.match","title":"<code>match(other)</code>","text":"<p>Tests whether term matches <code>other</code>.</p> <p>If term matches <code>other</code>, returns a variable instantiation theta that can be used to unify both term and <code>other</code>.  Otherwise, return <code>None</code>.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Term</code>)           \u2013            <p>Term.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Theta | None</code>           \u2013            <p>A variable instantiation theta if successful; <code>None</code> otherwise.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.rename","title":"<code>rename(exclude=(), rename=None)</code>","text":"<p>Renames all variables occurring in term.</p> <p>Picks name variants not occurring in <code>exclude</code>.</p> <p>Uses <code>rename</code> (if given) to generate name variants.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>Iterable[Term | str]</code>, default:                   <code>()</code> )           \u2013            <p>Name exclusion list.</p> </li> <li> <code>rename</code>               (<code>Callable[[str], Iterator[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Name variant generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Term.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Term.unify","title":"<code>unify(*eqs)</code>  <code>classmethod</code>","text":"<p>Computes an instantiation that unifies term equations.</p> <p>Parameters:</p> <ul> <li> <code>eqs</code>               (<code>tuple[Term, Term]</code>, default:                   <code>()</code> )           \u2013            <p>Pairs of terms (potential equations).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Theta | None</code>           \u2013            <p>A variable instantiation theta if successful; <code>None</code> otherwise.</p> </li> </ul>"},{"location":"api/model/term/term/#kif_lib.Theta","title":"<code>Theta = Mapping['Variable', Optional['Term']]</code>  <code>module-attribute</code>","text":""},{"location":"api/model/term/open_term/open_term/","title":"Open Term","text":""},{"location":"api/model/term/open_term/open_term/#kif_lib.OpenTerm","title":"<code>OpenTerm</code>","text":"<p>               Bases: <code>Term[Unpack[Ts]]</code></p> <p>Abstract base class for open terms.</p>"},{"location":"api/model/term/open_term/template/","title":"Template","text":""},{"location":"api/model/term/open_term/template/#kif_lib.Template","title":"<code>Template</code>","text":"<p>               Bases: <code>OpenTerm</code></p> <p>Abstract base class for templates.</p>"},{"location":"api/model/term/open_term/variable/","title":"Variable","text":""},{"location":"api/model/term/open_term/variable/#kif_lib.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>OpenTerm</code></p> <p>Base class for variables.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name or <code>None</code> (fresh name).</p> </li> <li> <code>term_class</code>               (<code>type[Term] | None</code>, default:                   <code>None</code> )           \u2013            <p>Term class.</p> </li> </ul>"},{"location":"api/model/term/open_term/variable/#kif_lib.Variable.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of variable.</p>"},{"location":"api/model/term/open_term/variable/#kif_lib.Variable.coerce","title":"<code>coerce(variable_class=None)</code>","text":"<p>Coerces variable into <code>variable_class</code>.</p> <p>If variable cannot be coerced, raises an error.</p> <p>Parameters:</p> <ul> <li> <code>variable_class</code>               (<code>TVariableClass | None</code>, default:                   <code>None</code> )           \u2013            <p>Variable class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Variable.</p> </li> </ul>"},{"location":"api/model/term/open_term/variable/#kif_lib.Variable.get_name","title":"<code>get_name()</code>","text":"<p>Gets the name of variable.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Name.</p> </li> </ul>"},{"location":"api/model/term/open_term/variable/#kif_lib.Variables","title":"<code>Variables(name, *names)</code>","text":"<p>Constructs one or more variables.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>Name or <code>None</code> (fresh name).</p> </li> <li> <code>names</code>               (<code>str | TVariableClass | None</code>, default:                   <code>()</code> )           \u2013            <p>Names or <code>None</code> values (fresh names) or variable classes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Variable]</code>           \u2013            <p>The resulting variables.</p> </li> </ul>"},{"location":"api/model/value/value/","title":"Value","text":""},{"location":"api/model/value/value/#kif_lib.Value","title":"<code>Value</code>","text":"<p>               Bases: <code>ClosedTerm[Unpack[Ts]]</code></p> <p>Abstract base class for values.</p>"},{"location":"api/model/value/value/#kif_lib.Value.display","title":"<code>display(language=None, format=None, context=None)</code>","text":"<p>Gets a human-readable representation of value in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>format</code>               (<code>TDisplayFormat | None</code>, default:                   <code>None</code> )           \u2013            <p>Format.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Human-readable representation.</p> </li> </ul>"},{"location":"api/model/value/value/#kif_lib.Value.n3","title":"<code>n3()</code>","text":"<p>Gets the simple value of value in N3 format.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Simple value in N3 format.</p> </li> </ul>"},{"location":"api/model/value/data_value/data_value/","title":"Data Value","text":""},{"location":"api/model/value/data_value/data_value/#kif_lib.DataValue","title":"<code>DataValue</code>","text":"<p>               Bases: <code>Value[Unpack[Ts]]</code></p> <p>Abstract base class for data values.</p>"},{"location":"api/model/value/data_value/data_value/#kif_lib.ShallowDataValue","title":"<code>ShallowDataValue</code>","text":"<p>               Bases: <code>DataValue[str, Unpack[Ts]]</code></p> <p>Abstract base class for shallow data values.</p>"},{"location":"api/model/value/data_value/data_value/#kif_lib.ShallowDataValue.content","title":"<code>content()</code>","text":"<p>The content of shallow data value.</p>"},{"location":"api/model/value/data_value/data_value/#kif_lib.ShallowDataValue.get_content","title":"<code>get_content()</code>","text":"<p>Gets the content of shallow data value.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String content.</p> </li> </ul>"},{"location":"api/model/value/data_value/data_value/#kif_lib.DeepDataValue","title":"<code>DeepDataValue</code>","text":"<p>               Bases: <code>DataValue[Unpack[Ts]]</code></p> <p>Abstract base class for deep data values.</p>"},{"location":"api/model/value/data_value/external_id/","title":"External Id","text":""},{"location":"api/model/value/data_value/external_id/#kif_lib.ExternalId","title":"<code>ExternalId</code>","text":"<p>               Bases: <code>String</code></p> <p>External id.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>VTStringContent</code>)           \u2013            <p>External id content.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/","title":"IRI","text":""},{"location":"api/model/value/data_value/iri/#kif_lib.IRI","title":"<code>IRI</code>","text":"<p>               Bases: <code>ShallowDataValue</code></p> <p>IRI.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>VT_IRI_Content</code>)           \u2013            <p>IRI content.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.prefix","title":"<code>prefix</code>  <code>property</code>","text":"<p>The prefix of IRI in KIF context.</p>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.resolver","title":"<code>resolver</code>  <code>property</code>","text":"<p>The entity resolver of IRI in KIF context.</p>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.schema","title":"<code>schema</code>  <code>property</code>","text":"<p>The property schema of IRI in KIF context.</p>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.Descriptor","title":"<code>Descriptor</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>IRI descriptor.</p>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.describe","title":"<code>describe()</code>","text":"<p>Gets the descriptor of IRI in KIF context.</p> <p>Returns:</p> <ul> <li> <code>Descriptor | None</code>           \u2013            <p>IRI descriptor or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.get_prefix","title":"<code>get_prefix()</code>","text":"<p>Gets the prefix of IRI in KIF context.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Prefix or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.get_resolver","title":"<code>get_resolver()</code>","text":"<p>Gets the entity resolver of IRI in KIF context.</p> <p>Returns:</p> <ul> <li> <code>Store | None</code>           \u2013            <p>Store or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.get_schema","title":"<code>get_schema()</code>","text":"<p>Gets the property schema of IRI in KIF context.</p> <p>Returns:</p> <ul> <li> <code>Schema | None</code>           \u2013            <p>Property schema or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.register","title":"<code>register(prefix=None, resolver=None, schema=None)</code>","text":"<p>Adds or updates IRI data in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>TString | None</code>, default:                   <code>None</code> )           \u2013            <p>Prefix.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>schema</code>               (<code>TSchema | None</code>, default:                   <code>None</code> )           \u2013            <p>Property schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IRI</code>           \u2013            <p>IRI.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.split","title":"<code>split()</code>","text":"<p>Splits IRI into namespace and name.</p> <p>Returns:</p> <ul> <li> <code>tuple[IRI, str]</code>           \u2013            <p>The namespace and name of IRI.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.unregister","title":"<code>unregister(prefix=False, resolver=False, schema=False)</code>","text":"<p>Remove IRI data from KIF context.</p> <p>If called with no arguments, removes all IRI data.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove prefix.</p> </li> <li> <code>resolver</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove resolver.</p> </li> <li> <code>schema</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove property schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/value/data_value/iri/#kif_lib.IRI.validate","title":"<code>validate()</code>","text":"<p>Validates IRI.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>IRI.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>`ValueError`</code>             \u2013            <p>IRI is invalid.</p> </li> </ul>"},{"location":"api/model/value/data_value/quantity/","title":"Quantity","text":""},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity","title":"<code>Quantity</code>","text":"<p>               Bases: <code>DeepDataValue[Decimal, Optional[Item], Optional[Decimal], Optional[Decimal]]</code></p> <p>Quantity.</p> <p>Parameters:</p> <ul> <li> <code>amount</code>               (<code>VTQuantityContent</code>)           \u2013            <p>Amount.</p> </li> <li> <code>unit</code>               (<code>VTItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Unit.</p> </li> <li> <code>lower_bound</code>               (<code>VTQuantityContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Lower bound.</p> </li> <li> <code>upper_bound</code>               (<code>VTQuantityContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Upper bound.</p> </li> </ul>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.amount","title":"<code>amount()</code>","text":"<p>The amount of quantity.</p>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.get_amount","title":"<code>get_amount()</code>","text":"<p>Gets the amount of quantity.</p> <p>Returns:</p> <ul> <li> <code>Decimal</code>           \u2013            <p>Amount.</p> </li> </ul>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.get_lower_bound","title":"<code>get_lower_bound(default=None)</code>","text":"<p>Gets the lower bound of quantity.</p> <p>If the lower bound is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Decimal | None</code>, default:                   <code>None</code> )           \u2013            <p>Default lower bound.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Decimal | None</code>           \u2013            <p>Lower bound.</p> </li> </ul>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.get_unit","title":"<code>get_unit(default=None)</code>","text":"<p>Gets the unit of quantity.</p> <p>If the unit is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Item | None</code>, default:                   <code>None</code> )           \u2013            <p>Default unit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item | None</code>           \u2013            <p>Unit.</p> </li> </ul>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.get_upper_bound","title":"<code>get_upper_bound(default=None)</code>","text":"<p>Gets the upper bound of quantity.</p> <p>If the upper bound is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Decimal | None</code>, default:                   <code>None</code> )           \u2013            <p>Default upper bound.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Decimal | None</code>           \u2013            <p>Upper bound.</p> </li> </ul>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.lower_bound","title":"<code>lower_bound()</code>","text":"<p>The lower bound of quantity.</p>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.unit","title":"<code>unit()</code>","text":"<p>The unit of quantity.</p>"},{"location":"api/model/value/data_value/quantity/#kif_lib.Quantity.upper_bound","title":"<code>upper_bound()</code>","text":"<p>The upper bound of quantity.</p>"},{"location":"api/model/value/data_value/string/","title":"String","text":""},{"location":"api/model/value/data_value/string/#kif_lib.String","title":"<code>String</code>","text":"<p>               Bases: <code>ShallowDataValue</code></p> <p>String.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>VTStringContent</code>)           \u2013            <p>String content.</p> </li> </ul>"},{"location":"api/model/value/data_value/text/","title":"Text","text":""},{"location":"api/model/value/data_value/text/#kif_lib.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>ShallowDataValue[str]</code></p> <p>Monolingual text.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>VTTextContent</code>)           \u2013            <p>Text content.</p> </li> <li> <code>language</code>               (<code>VTTextContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> </ul>"},{"location":"api/model/value/data_value/text/#kif_lib.Text.get_language","title":"<code>get_language()</code>","text":"<p>Gets the language of text.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Language.</p> </li> </ul>"},{"location":"api/model/value/data_value/text/#kif_lib.Text.language","title":"<code>language()</code>","text":"<p>The language of text.</p>"},{"location":"api/model/value/data_value/time/","title":"Time","text":""},{"location":"api/model/value/data_value/time/#kif_lib.Time","title":"<code>Time</code>","text":"<p>               Bases: <code>DeepDataValue[datetime, Optional[int], Optional[int], Optional[Item]]</code></p> <p>Time.</p> <p>Parameters:</p> <ul> <li> <code>time</code>               (<code>VTTimeContent</code>)           \u2013            <p>Time.</p> </li> <li> <code>precision</code>               (<code>VTTimePrecisionContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Precision.</p> </li> <li> <code>timezone</code>               (<code>VTTimeTimezoneContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Time zone.</p> </li> <li> <code>calendar</code>               (<code>VTItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Calendar model.</p> </li> </ul>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.calendar","title":"<code>calendar</code>  <code>property</code>","text":"<p>The calendar model of time.</p>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.precision","title":"<code>precision</code>  <code>property</code>","text":"<p>The precision of time.</p>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.time","title":"<code>time</code>  <code>property</code>","text":"<p>The date-time of time.</p>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.timezone","title":"<code>timezone</code>  <code>property</code>","text":"<p>The timezone of time.</p>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.Precision","title":"<code>Precision</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Time precision.</p>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.get_calendar","title":"<code>get_calendar(default=None)</code>","text":"<p>Gets the calendar model of time.</p> <p>If the calendar model is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Item | None</code>, default:                   <code>None</code> )           \u2013            <p>Default calendar model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item | None</code>           \u2013            <p>Calendar model.</p> </li> </ul>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.get_precision","title":"<code>get_precision(default=None)</code>","text":"<p>Gets the precision of time.</p> <p>If the precision is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Precision | None</code>, default:                   <code>None</code> )           \u2013            <p>Default precision.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Precision | None</code>           \u2013            <p>Precision.</p> </li> </ul>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.get_time","title":"<code>get_time()</code>","text":"<p>Gets the date-time of time.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>Datetime.</p> </li> </ul>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.get_timezone","title":"<code>get_timezone(default=None)</code>","text":"<p>Gets the timezone of time.</p> <p>If the timezone is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Default timezone.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Timezone.</p> </li> </ul>"},{"location":"api/model/value/data_value/time/#kif_lib.Time.now","title":"<code>now(precision=None, timezone=None, calendar=None)</code>  <code>classmethod</code>","text":"<p>Constructs a time object with the current date-time.</p> <p>Parameters:</p> <ul> <li> <code>precision</code>               (<code>VTTimePrecisionContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Precision.</p> </li> <li> <code>timezone</code>               (<code>VTTimeTimezoneContent | None</code>, default:                   <code>None</code> )           \u2013            <p>Time zone.</p> </li> <li> <code>calendar</code>               (<code>VTItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Calendar model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Time.</p> </li> </ul>"},{"location":"api/model/value/entity/entity/","title":"Entity","text":""},{"location":"api/model/value/entity/entity/#kif_lib.Entity","title":"<code>Entity</code>","text":"<p>               Bases: <code>Value[IRI, Unpack[Ts]]</code></p> <p>Abstract base class for entities.</p>"},{"location":"api/model/value/entity/entity/#kif_lib.Entity.get_iri","title":"<code>get_iri()</code>","text":"<p>Gets the iri of entity.</p> <p>Returns:</p> <ul> <li> <code>IRI</code>           \u2013            <p>IRI.</p> </li> </ul>"},{"location":"api/model/value/entity/entity/#kif_lib.Entity.get_resolver","title":"<code>get_resolver()</code>","text":"<p>Gets the resolver of entity in KIF context.</p> <p>Returns:</p> <ul> <li> <code>Store | None</code>           \u2013            <p>Store or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/entity/#kif_lib.Entity.iri","title":"<code>iri()</code>","text":"<p>The iri of entity.</p>"},{"location":"api/model/value/entity/entity/#kif_lib.Entity.resolver","title":"<code>resolver()</code>","text":"<p>The resolver of entity in KIF context.</p>"},{"location":"api/model/value/entity/item/","title":"Item","text":""},{"location":"api/model/value/entity/item/#kif_lib.Item","title":"<code>Item</code>","text":"<p>               Bases: <code>Entity</code></p> <p>Person or thing.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>VTItemContent</code>)           \u2013            <p>IRI.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.Descriptor","title":"<code>Descriptor</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Item descriptor in KIF context.</p>"},{"location":"api/model/value/entity/item/#kif_lib.Item.aliases","title":"<code>aliases()</code>","text":"<p>The aliases of item in KIF context.</p>"},{"location":"api/model/value/entity/item/#kif_lib.Item.describe","title":"<code>describe(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes item in KIF context.</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>resolve</code> is <code>True</code>, resolves item data.</p> <p>If <code>resolver</code> is given, uses it to resolve item data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Descriptor | None</code>           \u2013            <p>Item descriptor or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.describe_using_repr","title":"<code>describe_using_repr(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes item in KIF context using repr. format.</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>resolve</code> is <code>True</code>, resolves item data.</p> <p>If <code>resolver</code> is given, uses it to resolve item data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Repr. string.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.describe_using_statements","title":"<code>describe_using_statements(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes item in KIF context using statements.</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>resolve</code> is <code>True</code>, resolves item data.</p> <p>If <code>resolver</code> is given, uses it to resolve item data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Statement]</code>           \u2013            <p>Statement iterator.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.description","title":"<code>description()</code>","text":"<p>The description of item in KIF context.</p>"},{"location":"api/model/value/entity/item/#kif_lib.Item.descriptor_to_snaks","title":"<code>descriptor_to_snaks(descriptor)</code>  <code>classmethod</code>","text":"<p>Converts item descriptor to (value) snaks.</p> <p>Parameters:</p> <ul> <li> <code>descriptor</code>               (<code>Descriptor</code>)           \u2013            <p>Item descriptor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[ValueSnak]</code>           \u2013            <p>(Value) snaks.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.get_aliases","title":"<code>get_aliases(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the aliases of item in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve aliases.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Set[Text] | None</code>           \u2013            <p>Aliases or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.get_description","title":"<code>get_description(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the description of item in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve description.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Description or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.get_label","title":"<code>get_label(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the label of item in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve label.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Label or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.label","title":"<code>label()</code>","text":"<p>The label of item in KIF context.</p>"},{"location":"api/model/value/entity/item/#kif_lib.Item.register","title":"<code>register(label=None, labels=None, alias=None, aliases=None, description=None, descriptions=None, context=None)</code>","text":"<p>Adds or updates item data in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>labels</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Labels.</p> </li> <li> <code>alias</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Alias.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>descriptions</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Descriptions.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Item.unregister","title":"<code>unregister(label=None, labels=None, alias=None, aliases=None, description=None, descriptions=None, label_language=None, alias_language=None, description_language=None, all_labels=False, all_aliases=False, all_descriptions=False, context=None)</code>","text":"<p>Removes item data from KIF context.</p> <p>If called with no arguments, removes all item data.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>labels</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Labels.</p> </li> <li> <code>alias</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Alias.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>descriptions</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Descriptions.</p> </li> <li> <code>label_language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>alias_language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>description_language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>all_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove all labels.</p> </li> <li> <code>all_aliases</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove all aliases.</p> </li> <li> <code>all_descriptions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove all descriptions.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/value/entity/item/#kif_lib.Items","title":"<code>Items(iri, *iris)</code>","text":"<p>Constructs one or more items.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>VTItemContent</code>)           \u2013            <p>IRI.</p> </li> <li> <code>iris</code>               (<code>VTItemContent</code>, default:                   <code>()</code> )           \u2013            <p>IRIs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Item]</code>           \u2013            <p>The resulting items.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/","title":"Lexeme","text":""},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme","title":"<code>Lexeme</code>","text":"<p>               Bases: <code>Entity</code></p> <p>Word or phrase.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>VTLexemeContent</code>)           \u2013            <p>IRI.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.Descriptor","title":"<code>Descriptor</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Lexeme descriptor.</p>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.category","title":"<code>category()</code>","text":"<p>The category of lexeme in KIF context.</p>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.describe","title":"<code>describe(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes lexeme in KIF context.</p> <p>If <code>resolve</code> is <code>True</code>, resolves lexeme data.</p> <p>If <code>resolver</code> is given, uses it to resolve lexeme data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Descriptor | None</code>           \u2013            <p>Lexeme descriptor or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.describe_using_repr","title":"<code>describe_using_repr(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes lexeme in KIF context using repr. format.</p> <p>If <code>resolve</code> is <code>True</code>, resolves lexeme data.</p> <p>If <code>resolver</code> is given, uses it to resolve lexeme data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Repr. string.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.describe_using_statements","title":"<code>describe_using_statements(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes lexeme in KIF context using statements.</p> <p>If <code>resolve</code> is <code>True</code>, resolves lexeme data.</p> <p>If <code>resolver</code> is given, uses it to resolve lexeme data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Statement]</code>           \u2013            <p>Statement iterator.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.descriptor_to_snaks","title":"<code>descriptor_to_snaks(descriptor)</code>  <code>classmethod</code>","text":"<p>Converts lexeme descriptor to (value) snaks.</p> <p>Parameters:</p> <ul> <li> <code>descriptor</code>               (<code>Descriptor</code>)           \u2013            <p>Lexeme descriptor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[ValueSnak]</code>           \u2013            <p>(Value) snaks.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.get_category","title":"<code>get_category(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the lexical category of lexeme in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve lexical category.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item | None</code>           \u2013            <p>Lexical category or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.get_language","title":"<code>get_language(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the language of lexeme in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve language.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item | None</code>           \u2013            <p>Language or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.get_lemma","title":"<code>get_lemma(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the lemma of lexeme in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve lemma.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Lemma or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.language","title":"<code>language()</code>","text":"<p>The language of lexeme in KIF context.</p>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.lemma","title":"<code>lemma()</code>","text":"<p>The lemma of lexeme in KIF context.</p>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.register","title":"<code>register(lemma=None, category=None, language=None, context=None)</code>","text":"<p>Adds or updates lexeme data in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>lemma</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Lemma.</p> </li> <li> <code>category</code>               (<code>TItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Lexical category.</p> </li> <li> <code>language</code>               (<code>TItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Lexeme.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexeme.unregister","title":"<code>unregister(lemma=False, category=False, language=False, context=None)</code>","text":"<p>Removes lexeme data from KIF context.</p> <p>If called with no arguments, removes all lexeme data.</p> <p>Parameters:</p> <ul> <li> <code>lemma</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove lemma.</p> </li> <li> <code>category</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove category.</p> </li> <li> <code>language</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove language.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/value/entity/lexeme/#kif_lib.Lexemes","title":"<code>Lexemes(iri, *iris)</code>","text":"<p>Constructs one or more lexemes.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>VTLexemeContent</code>)           \u2013            <p>IRI.</p> </li> <li> <code>iris</code>               (<code>VTLexemeContent</code>, default:                   <code>()</code> )           \u2013            <p>IRIs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Lexeme]</code>           \u2013            <p>The resulting lexemes.</p> </li> </ul>"},{"location":"api/model/value/entity/property/","title":"Property","text":""},{"location":"api/model/value/entity/property/#kif_lib.Property","title":"<code>Property</code>","text":"<p>               Bases: <code>Entity[Union[Datatype, None]]</code></p> <p>Binary relationship.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>VTPropertyContent</code>)           \u2013            <p>IRI.</p> </li> <li> <code>range</code>               (<code>VTDatatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.aliases","title":"<code>aliases</code>  <code>property</code>","text":"<p>The aliases of property in KIF context.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.description","title":"<code>description</code>  <code>property</code>","text":"<p>The description of property in KIF context.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.inverse","title":"<code>inverse</code>  <code>property</code>","text":"<p>The inverse of property in KIF context.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.label","title":"<code>label</code>  <code>property</code>","text":"<p>The label of property in KIF context.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.range","title":"<code>range</code>  <code>property</code>","text":"<p>The range of property.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.registered_range","title":"<code>registered_range</code>  <code>property</code>","text":"<p>The range of property in KIF context.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.schema","title":"<code>schema</code>  <code>property</code>","text":"<p>The resolved schema of property in KIF context.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.Descriptor","title":"<code>Descriptor</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Property descriptor.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.Schema","title":"<code>Schema</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Property schema.</p>"},{"location":"api/model/value/entity/property/#kif_lib.Property.__rtruediv__","title":"<code>__rtruediv__(path)</code>","text":"<p>Constructs a sequence path from property.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>TPath</code>)           \u2013            <p>Path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SequencePath</code>           \u2013            <p>Sequence path.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.__truediv__","title":"<code>__truediv__(path)</code>","text":"<p>Constructs a sequence path from property.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>TPath | Literal[1]</code>)           \u2013            <p>Path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Sequence path.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.describe","title":"<code>describe(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes property in KIF context.</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>resolve</code> is <code>True</code>, resolves property data.</p> <p>If <code>resolver</code> is given, uses it to resolve property data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Descriptor | None</code>           \u2013            <p>Property descriptor or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.describe_using_repr","title":"<code>describe_using_repr(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes property in KIF context using repr. format.</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>resolve</code> is <code>True</code>, resolves property data.</p> <p>If <code>resolver</code> is given, uses it to resolve property data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Repr. string.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.describe_using_statements","title":"<code>describe_using_statements(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Describes property in KIF context using statements.</p> <p>If <code>language</code> is given, resolves only text in <code>language</code>. Otherwise, resolves text in all languages.</p> <p>If <code>resolve</code> is <code>True</code>, resolves property data.</p> <p>If <code>resolver</code> is given, uses it to resolve property data. Otherwise, uses the resolver registered in context (if any).</p> <p>If <code>force</code> is given, forces resolution.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve descriptor.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Statement]</code>           \u2013            <p>Statement iterator.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.descriptor_to_snaks","title":"<code>descriptor_to_snaks(descriptor)</code>  <code>classmethod</code>","text":"<p>Converts property descriptor to (value) snaks.</p> <p>Parameters:</p> <ul> <li> <code>descriptor</code>               (<code>Descriptor</code>)           \u2013            <p>Property descriptor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[ValueSnak]</code>           \u2013            <p>(Value) snaks.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_aliases","title":"<code>get_aliases(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the aliases of property in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve aliases.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Set[Text] | None</code>           \u2013            <p>Aliases or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_description","title":"<code>get_description(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the description of property in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve description.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Description or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_inverse","title":"<code>get_inverse(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the inverse of property in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve inverse.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property | None</code>           \u2013            <p>Property or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_label","title":"<code>get_label(language=None, resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the label of property in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve label.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Text | None</code>           \u2013            <p>Label or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_range","title":"<code>get_range(default=None)</code>","text":"<p>Gets the range of property.</p> <p>If range is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Datatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Default range.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Datatype | None</code>           \u2013            <p>Datatype.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_registered_range","title":"<code>get_registered_range(resolve=None, resolver=None, force=None, context=None)</code>","text":"<p>Gets the range of property in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>resolve</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to resolve range.</p> </li> <li> <code>resolver</code>               (<code>Store | None</code>, default:                   <code>None</code> )           \u2013            <p>Resolver store.</p> </li> <li> <code>force</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to force resolution.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Datatype | None</code>           \u2013            <p>Range or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.get_schema","title":"<code>get_schema(default=None, resolve=True, context=None)</code>","text":"<p>Gets the schema of property in KIF context.</p> <p>If property has no associated schema, assumes <code>default</code>.</p> <p>If <code>resolve</code> is <code>True</code>, returns a resolved schema, i.e., one in which namespaces are resolved into absolute IRIs by concatenating the namespace IRI with the name part of property IRI.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Schema | None</code>, default:                   <code>None</code> )           \u2013            <p>Default schema.</p> </li> <li> <code>resolve</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to resolve the returned schema.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Schema | None</code>           \u2013            <p>Property schema or <code>None</code>.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.register","title":"<code>register(label=None, labels=None, alias=None, aliases=None, description=None, descriptions=None, range=None, inverse=None, context=None)</code>","text":"<p>Adds or updates property data in KIF context.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>labels</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Labels.</p> </li> <li> <code>alias</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Alias.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>descriptions</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Descriptions.</p> </li> <li> <code>range</code>               (<code>TDatatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Range.</p> </li> <li> <code>inverse</code>               (<code>TProperty | None</code>, default:                   <code>None</code> )           \u2013            <p>Inverse property.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Property.unregister","title":"<code>unregister(label=None, labels=None, alias=None, aliases=None, description=None, descriptions=None, label_language=None, alias_language=None, description_language=None, all_labels=False, all_aliases=False, all_descriptions=False, range=False, inverse=False, context=None)</code>","text":"<p>Removes property data from KIF context.</p> <p>If called with no arguments, removes all property data.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>labels</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Labels.</p> </li> <li> <code>alias</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Alias.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>descriptions</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Descriptions.</p> </li> <li> <code>label_language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>alias_language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>description_language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>all_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove all labels.</p> </li> <li> <code>all_aliases</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove all aliases.</p> </li> <li> <code>all_descriptions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove all descriptions.</p> </li> <li> <code>range</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove range.</p> </li> <li> <code>inverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to remove inverse.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/model/value/entity/property/#kif_lib.Properties","title":"<code>Properties(iri, *iris)</code>","text":"<p>Constructs one or more properties.</p> <p>Parameters:</p> <ul> <li> <code>iri</code>               (<code>VTPropertyContent</code>)           \u2013            <p>IRI.</p> </li> <li> <code>iris</code>               (<code>VTPropertyContent</code>, default:                   <code>()</code> )           \u2013            <p>IRIs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Property]</code>           \u2013            <p>The resulting properties.</p> </li> </ul>"},{"location":"api/model/value/entity/pseudo_property/","title":"Pseudo-Property","text":""},{"location":"api/model/value/entity/pseudo_property/#kif_lib.PseudoProperty","title":"<code>PseudoProperty</code>","text":"<p>               Bases: <code>Property</code></p> <p>Base class for pseudo-properties.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.TypeProperty","title":"<code>TypeProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"type\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.SubtypeProperty","title":"<code>SubtypeProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"subtype\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.LabelProperty","title":"<code>LabelProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"label\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.AliasProperty","title":"<code>AliasProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"alias\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.DescriptionProperty","title":"<code>DescriptionProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"description\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.LemmaProperty","title":"<code>LemmaProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"lemma\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.LexicalCategoryProperty","title":"<code>LexicalCategoryProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"lexical category\" pseudo-property.</p>"},{"location":"api/model/value/entity/pseudo_property/#kif_lib.LanguageProperty","title":"<code>LanguageProperty</code>","text":"<p>               Bases: <code>PseudoProperty</code></p> <p>The \"language\" pseudo-property.</p>"},{"location":"api/search/abc/","title":"Search","text":""},{"location":"api/search/abc/#kif_lib.Search","title":"<code>Search</code>","text":"<p>               Bases: <code>Engine[TOptions]</code></p> <p>Abstract base class for search engines.</p>"},{"location":"api/search/abc/#kif_lib.Search.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for search errors.</p>"},{"location":"api/search/abc/#kif_lib.Search.__init__","title":"<code>__init__(search_name, *args, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Initializes :class:<code>Search</code>.</p> <p>Parameters:</p> <ul> <li> <code>search_name</code>               (<code>str</code>)           \u2013            <p>Name of the search plugin to instantiate.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Arguments.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.aitem","title":"<code>aitem(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.item</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.aitem_data","title":"<code>aitem_data(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.item_data</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.aitem_descriptor","title":"<code>aitem_descriptor(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.item_descriptor</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.alexeme","title":"<code>alexeme(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.lexeme</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.alexeme_data","title":"<code>alexeme_data(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.lexeme_data</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.alexeme_descriptor","title":"<code>alexeme_descriptor(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.lexeme_descriptor</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.aproperty","title":"<code>aproperty(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.property</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.aproperty_data","title":"<code>aproperty_data(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.property_data</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.aproperty_descriptor","title":"<code>aproperty_descriptor(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Search.property_descriptor</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.default_language","title":"<code>default_language()</code>","text":"<p>The default value for :attr:<code>Search.language</code>.</p>"},{"location":"api/search/abc/#kif_lib.Search.get_default_language","title":"<code>get_default_language()</code>","text":"<p>Gets the default value for :attr:<code>Search.language</code>.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Default Language.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.get_language","title":"<code>get_language(default=None)</code>","text":"<p>Gets the language of search.</p> <p>If the language is <code>None</code>, returns <code>default</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Default language.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Language or <code>None</code>.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.item","title":"<code>item(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for items matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Item]</code>           \u2013            <p>An iterator of items matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.item_data","title":"<code>item_data(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for item data matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[TData]</code>           \u2013            <p>An iterator of item data matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.item_descriptor","title":"<code>item_descriptor(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for item-descriptor pairs matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[tuple[Item, Descriptor]]</code>           \u2013            <p>An iterator of \"(item, descriptor)\" pairs matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.lexeme","title":"<code>lexeme(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for lexemes matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Lexeme]</code>           \u2013            <p>An iterator of lexemes matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.lexeme_data","title":"<code>lexeme_data(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for lexeme data matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[TData]</code>           \u2013            <p>An iterator of lexeme data matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.lexeme_descriptor","title":"<code>lexeme_descriptor(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for lexeme-descriptor pairs matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[tuple[Lexeme, Descriptor]]</code>           \u2013            <p>An iterator of \"(lexeme, descriptor)\" pairs matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.property","title":"<code>property(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for properties matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Property]</code>           \u2013            <p>An iterator of properties matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.property_data","title":"<code>property_data(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for property data matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[TData]</code>           \u2013            <p>An iterator of property data matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.property_descriptor","title":"<code>property_descriptor(search, debug=None, language=None, limit=None, lookahead=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Searches for property-descriptor pairs matching search.</p> <p>Parameters:</p> <ul> <li> <code>search</code>               (<code>str</code>)           \u2013            <p>Search string.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language of search.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[tuple[Property, Descriptor]]</code>           \u2013            <p>An iterator of \"(property, descriptor)\" pairs matching search.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.set_language","title":"<code>set_language(language=None)</code>","text":"<p>Sets the language of search.</p> <p>If <code>language</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.to_item","title":"<code>to_item(data)</code>","text":"<p>Parses item data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>TData</code>)           \u2013            <p>Item data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.to_item_descriptor","title":"<code>to_item_descriptor(data)</code>","text":"<p>Parses item descriptor data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>TData</code>)           \u2013            <p>Item data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Item, Descriptor]</code>           \u2013            <p>Item-descriptor pair.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.to_lexeme","title":"<code>to_lexeme(data)</code>","text":"<p>Parses lexeme data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>TData</code>)           \u2013            <p>Lexeme data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lexeme</code>           \u2013            <p>Lexeme.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.to_lexeme_descriptor","title":"<code>to_lexeme_descriptor(data)</code>","text":"<p>Parses lexeme descriptor data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>TData</code>)           \u2013            <p>Lexeme data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Lexeme, Descriptor]</code>           \u2013            <p>Lexeme-descriptor pair.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.to_property","title":"<code>to_property(data)</code>","text":"<p>Parses property data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>TData</code>)           \u2013            <p>Property data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/search/abc/#kif_lib.Search.to_property_descriptor","title":"<code>to_property_descriptor(data)</code>","text":"<p>Parses property descriptor data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>TData</code>)           \u2013            <p>Property data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Property, Descriptor]</code>           \u2013            <p>Property-descriptor pair.</p> </li> </ul>"},{"location":"api/store/abc/","title":"Store","text":""},{"location":"api/store/abc/#kif_lib.Store","title":"<code>Store</code>","text":"<p>               Bases: <code>Engine[TOptions]</code></p> <p>Abstract base class for store engines.</p>"},{"location":"api/store/abc/#kif_lib.Store.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Error</code></p> <p>Base class for store errors.</p>"},{"location":"api/store/abc/#kif_lib.Store.__init__","title":"<code>__init__(store_name, *args, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, context=None, **kwargs)</code>","text":"<p>Initializes :class:<code>Store</code>.</p> <p>Parameters:</p> <ul> <li> <code>store_name</code>               (<code>str</code>)           \u2013            <p>Name of the store plugin to instantiate.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Arguments.</p> </li> <li> <code>base_filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Base filter.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to suppress duplicates.</p> </li> <li> <code>distinct_window_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Size of distinct look-back window.</p> </li> <li> <code>extra_references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra references to attach to statements.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>omega</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of disjoint subqueries.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>Context.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.aask","title":"<code>aask(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>Async version of :meth:<code>Store.ask</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.acontains","title":"<code>acontains(stmt)</code>  <code>async</code>","text":"<p>Async version of :meth:<code>Store.contains</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount","title":"<code>acount(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>Async version of :meth:<code>Store.count</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount_p","title":"<code>acount_p(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>:meth:<code>Store.acount</code> with projection on property.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount_pv","title":"<code>acount_pv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>:meth:<code>Store.acount</code> with projection on property and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount_s","title":"<code>acount_s(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>:meth:<code>Store.acount</code> with projection on subject.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount_sp","title":"<code>acount_sp(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>:meth:<code>Store.acount</code> with projection on subject and property.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount_sv","title":"<code>acount_sv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>:meth:<code>Store.acount</code> with projection on subject and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.acount_v","title":"<code>acount_v(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>:meth:<code>Store.acount</code> with projection on value.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter","title":"<code>afilter(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>Async version of :meth:<code>Store.filter</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_annotated","title":"<code>afilter_annotated(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, _annotate=lambda stmt: stmt.annotate(), **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with annotations.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_p","title":"<code>afilter_p(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with projection on property.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_pv","title":"<code>afilter_pv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with projection on property and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_s","title":"<code>afilter_s(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with projection on subject.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_sp","title":"<code>afilter_sp(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with projection on subject and property.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_sv","title":"<code>afilter_sv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with projection on subject and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.afilter_v","title":"<code>afilter_v(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.afilter</code> with projection on value.</p>"},{"location":"api/store/abc/#kif_lib.Store.amix","title":"<code>amix(*sources, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>  <code>async</code>","text":"<p>Async version of :meth:<code>Store.mix</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.ask","title":"<code>ask(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>Tests whether some statement matches filter.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Entity.</p> </li> <li> <code>property</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Property.</p> </li> <li> <code>value</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Value.</p> </li> <li> <code>snak_mask</code>               (<code>TSnakMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak mask.</p> </li> <li> <code>subject_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>property_mask</code>               (<code>TPropertyMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>value_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>rank_mask</code>               (<code>TRankMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank mask.</p> </li> <li> <code>best_ranked</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Best-ranked flag.</p> </li> <li> <code>language</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>annotated</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Annotated flag.</p> </li> <li> <code>snak</code>               (<code>Snak | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak.</p> </li> <li> <code>filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Filter.</p> </li> <li> <code>base_filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Base filter.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to suppress duplicates.</p> </li> <li> <code>distinct_window_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Size of distinct look-back window.</p> </li> <li> <code>extra_references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra references to attach to statements.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>omega</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of disjoint subqueries.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.contains","title":"<code>contains(stmt)</code>","text":"<p>Tests whether statement occurs in store.</p> <p>Parameters:</p> <ul> <li> <code>stmt</code>               (<code>Statement</code>)           \u2013            <p>Statement.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if successful; <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.count","title":"<code>count(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>Counts statements matching filter.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Entity.</p> </li> <li> <code>property</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Property.</p> </li> <li> <code>value</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Value.</p> </li> <li> <code>snak_mask</code>               (<code>TSnakMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak mask.</p> </li> <li> <code>subject_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>property_mask</code>               (<code>TPropertyMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>value_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>rank_mask</code>               (<code>TRankMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank mask.</p> </li> <li> <code>best_ranked</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Best-ranked flag.</p> </li> <li> <code>language</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>annotated</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Annotated flag.</p> </li> <li> <code>snak</code>               (<code>Snak | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak.</p> </li> <li> <code>filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Filter.</p> </li> <li> <code>base_filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Base filter.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to suppress duplicates.</p> </li> <li> <code>distinct_window_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Size of distinct look-back window.</p> </li> <li> <code>extra_references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra references to attach to statements.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>omega</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of disjoint subqueries.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of statements matching filter.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.count_p","title":"<code>count_p(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.count</code> with projection on property.</p>"},{"location":"api/store/abc/#kif_lib.Store.count_pv","title":"<code>count_pv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.count</code> with projection on subject and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.count_s","title":"<code>count_s(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.count</code> with projection on subject.</p>"},{"location":"api/store/abc/#kif_lib.Store.count_sp","title":"<code>count_sp(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.count</code> with projection on subject and property.</p>"},{"location":"api/store/abc/#kif_lib.Store.count_sv","title":"<code>count_sv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.count</code> with projection on subject and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.count_v","title":"<code>count_v(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.count</code> with projection on value.</p>"},{"location":"api/store/abc/#kif_lib.Store.default_base_filter","title":"<code>default_base_filter()</code>","text":"<p>The default value for :attr:<code>Store.base_filter</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.default_distinct","title":"<code>default_distinct()</code>","text":"<p>The default value for :attr:<code>Store.distinct</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.default_distinct_window_size","title":"<code>default_distinct_window_size()</code>","text":"<p>The default value for :attr:<code>Store.distinct_window_size</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.default_extra_references","title":"<code>default_extra_references()</code>","text":"<p>The default value for :attr:<code>Store.extra_references</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.default_omega","title":"<code>default_omega()</code>","text":"<p>The default value for :attr:<code>Store.omega</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter","title":"<code>filter(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>Searches for statements matching filter.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Entity.</p> </li> <li> <code>property</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Property.</p> </li> <li> <code>value</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Value.</p> </li> <li> <code>snak_mask</code>               (<code>TSnakMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak mask.</p> </li> <li> <code>subject_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>property_mask</code>               (<code>TPropertyMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>value_mask</code>               (<code>TDatatypeMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype mask.</p> </li> <li> <code>rank_mask</code>               (<code>TRankMask | None</code>, default:                   <code>None</code> )           \u2013            <p>Rank mask.</p> </li> <li> <code>best_ranked</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Best-ranked flag.</p> </li> <li> <code>language</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>annotated</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Annotated flag.</p> </li> <li> <code>snak</code>               (<code>Snak | None</code>, default:                   <code>None</code> )           \u2013            <p>Snak.</p> </li> <li> <code>filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Filter.</p> </li> <li> <code>base_filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Base filter.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to suppress duplicates.</p> </li> <li> <code>distinct_window_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Size of distinct look-back window.</p> </li> <li> <code>extra_references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra references to attach to statements.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>omega</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of disjoint subqueries.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Statement]</code>           \u2013            <p>An iterator of statements matching filter.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.filter_annotated","title":"<code>filter_annotated(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, _annotate=lambda stmt: stmt.annotate(), **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with annotations.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter_p","title":"<code>filter_p(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with projection on property.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter_pv","title":"<code>filter_pv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with projection on property and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter_s","title":"<code>filter_s(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with projection on subject.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter_sp","title":"<code>filter_sp(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with projection on subject and property.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter_sv","title":"<code>filter_sv(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with projection on subject and value.</p>"},{"location":"api/store/abc/#kif_lib.Store.filter_v","title":"<code>filter_v(subject=None, property=None, value=None, snak_mask=None, subject_mask=None, property_mask=None, value_mask=None, rank_mask=None, best_ranked=None, language=None, annotated=None, snak=None, filter=None, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>:meth:<code>Store.filter</code> with projection on value.</p>"},{"location":"api/store/abc/#kif_lib.Store.get_annotated","title":"<code>get_annotated()</code>","text":"<p>Gets the annotated flag of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Annotated flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_base_filter","title":"<code>get_base_filter()</code>","text":"<p>Gets the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_best_ranked","title":"<code>get_best_ranked()</code>","text":"<p>Gets the best-ranked flag of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Best-ranked flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_default_base_filter","title":"<code>get_default_base_filter()</code>","text":"<p>Gets the default value for :attr:<code>Store.base_filter</code>.</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>Default filter.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_default_distinct","title":"<code>get_default_distinct()</code>","text":"<p>Gets the default value for :attr:<code>Store.distinct</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Default distinct flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_default_distinct_window_size","title":"<code>get_default_distinct_window_size()</code>","text":"<p>Gets the default value for :attr:<code>Store.distinct_window_size</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Default distinct window-size.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_default_extra_references","title":"<code>get_default_extra_references()</code>","text":"<p>Gets the default value for :attr:<code>Store.extra_references</code>.</p> <p>Returns:</p> <ul> <li> <code>ReferenceRecordSet</code>           \u2013            <p>Reference record set.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_default_omega","title":"<code>get_default_omega()</code>","text":"<p>Gets the default value for :attr:<code>Store.omega</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Default omega value.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_distinct","title":"<code>get_distinct()</code>","text":"<p>Gets the distinct flag of store.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Distinct flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_distinct_window_size","title":"<code>get_distinct_window_size()</code>","text":"<p>Gets the distinct window-size of store.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Page size.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_extra_references","title":"<code>get_extra_references()</code>","text":"<p>Gets the extra references of store.</p> <p>Returns:</p> <ul> <li> <code>ReferenceRecordSet</code>           \u2013            <p>Reference record set.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_language","title":"<code>get_language()</code>","text":"<p>Gets the language of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Language.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_max_distinct_window_size","title":"<code>get_max_distinct_window_size()</code>","text":"<p>Gets the maximum value for :attr:<code>Store.distinct_window_size</code>.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Maximum distinct window-size.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_omega","title":"<code>get_omega()</code>","text":"<p>Gets the omega of store.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Omega.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_property","title":"<code>get_property()</code>","text":"<p>Gets the property fingerprint of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_property_mask","title":"<code>get_property_mask()</code>","text":"<p>Gets the property mask of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>PropertyMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_rank_mask","title":"<code>get_rank_mask()</code>","text":"<p>Gets the rank mask of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>RankMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_snak_mask","title":"<code>get_snak_mask()</code>","text":"<p>Gets the snak mask of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>SnakMask</code>           \u2013            <p>Snak mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_subject","title":"<code>get_subject()</code>","text":"<p>Gets the subject fingerprint of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_subject_mask","title":"<code>get_subject_mask()</code>","text":"<p>Gets the subject mask of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>DatatypeMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_value","title":"<code>get_value()</code>","text":"<p>Gets the value fingerprint of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>Fingerprint</code>           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.get_value_mask","title":"<code>get_value_mask()</code>","text":"<p>Gets the value mask of the base filter of store.</p> <p>Returns:</p> <ul> <li> <code>DatatypeMask</code>           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.max_distinct_window_size","title":"<code>max_distinct_window_size()</code>","text":"<p>The maximum value for :attr:<code>Store.distinct_window_size</code>.</p>"},{"location":"api/store/abc/#kif_lib.Store.mix","title":"<code>mix(*sources, base_filter=None, debug=None, distinct=None, distinct_window_size=None, extra_references=None, limit=None, lookahead=None, omega=None, page_size=None, timeout=None, **kwargs)</code>","text":"<p>Mixes sources of statement.</p> <p>If source is a :class:<code>Filter</code>, evaluates it over store it to obtain a statement iterator.</p> <p>Parameters:</p> <ul> <li> <code>sources</code>               (<code>Filter | Iterable[Statement]</code>, default:                   <code>()</code> )           \u2013            <p>Sources to mix.</p> </li> <li> <code>base_filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Base filter.</p> </li> <li> <code>debug</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to enable debugging mode.</p> </li> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to suppress duplicates.</p> </li> <li> <code>distinct_window_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Size of distinct look-back window.</p> </li> <li> <code>extra_references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra references to attach to statements.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit (maximum number) of responses.</p> </li> <li> <code>lookahead</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of pages to lookahead asynchronously.</p> </li> <li> <code>omega</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of disjoint subqueries.</p> </li> <li> <code>page_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size of paginated responses.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout of responses (in seconds).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Statement]</code>           \u2013            <p>An iterator of statements.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_annotated","title":"<code>set_annotated(annotated)</code>","text":"<p>Sets the annotated flag of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>annotated</code>               (<code>bool</code>)           \u2013            <p>Annotated flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_base_filter","title":"<code>set_base_filter(base_filter=None)</code>","text":"<p>Sets the base filter of store.</p> <p>If <code>filter</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>base_filter</code>               (<code>Filter | None</code>, default:                   <code>None</code> )           \u2013            <p>Filter.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_best_ranked","title":"<code>set_best_ranked(best_ranked)</code>","text":"<p>Sets the best-ranked flag of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>best_ranked</code>               (<code>bool</code>)           \u2013            <p>Best-ranked flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_distinct","title":"<code>set_distinct(distinct=None)</code>","text":"<p>Sets the distinct flag of store.</p> <p>If <code>distinct</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>distinct</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Distinct flag.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_distinct_window_size","title":"<code>set_distinct_window_size(distinct_window_size=None)</code>","text":"<p>Sets the page size of store.</p> <p>If <code>distinct_window_size</code> is negative or zero, assumes 1.</p> <p>If <code>distinct_window_size</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>distinct_window_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Page size.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_extra_references","title":"<code>set_extra_references(extra_references=None)</code>","text":"<p>Sets the extra references of store.</p> <p>If <code>extra_references</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>extra_references</code>               (<code>TReferenceRecordSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Reference record set.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_language","title":"<code>set_language(language)</code>","text":"<p>Sets the language of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>language</code>               (<code>TTextLanguage | None</code>)           \u2013            <p>Language.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_omega","title":"<code>set_omega(omega=None)</code>","text":"<p>Sets the omega of store.</p> <p>If <code>omega</code> is negative, assumes one.</p> <p>If <code>omega</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>omega</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Omega.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_property","title":"<code>set_property(property)</code>","text":"<p>Sets the property fingerprint of the base filter of store.</p> <p>If <code>property</code> is <code>None</code>, assumes the full fingerprint.</p> <p>Parameters:</p> <ul> <li> <code>property</code>               (<code>TFingerprint</code>)           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_property_mask","title":"<code>set_property_mask(property_mask)</code>","text":"<p>Sets the property mask of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>property_mask</code>               (<code>TPropertyMask</code>)           \u2013            <p>Property mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_rank_mask","title":"<code>set_rank_mask(rank_mask)</code>","text":"<p>Sets the rank mask of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>rank_mask</code>               (<code>TRankMask</code>)           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_snak_mask","title":"<code>set_snak_mask(snak_mask)</code>","text":"<p>Sets the snak mask of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>snak_mask</code>               (<code>TSnakMask</code>)           \u2013            <p>Snak mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_subject","title":"<code>set_subject(subject=None)</code>","text":"<p>Sets the subject fingerprint of the base filter of store.</p> <p>If <code>subject</code> is <code>None</code>, assumes the full fingerprint.</p> <p>Parameters:</p> <ul> <li> <code>subject</code>               (<code>TFingerprint | None</code>, default:                   <code>None</code> )           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_subject_mask","title":"<code>set_subject_mask(subject_mask)</code>","text":"<p>Sets the subject mask of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>subject_mask</code>               (<code>TDatatypeMask</code>)           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_value","title":"<code>set_value(value)</code>","text":"<p>Sets the value fingerprint of the base filter of store.</p> <p>If <code>value</code> is <code>None</code>, assumes the full fingerprint.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>TFingerprint</code>)           \u2013            <p>Fingerprint.</p> </li> </ul>"},{"location":"api/store/abc/#kif_lib.Store.set_value_mask","title":"<code>set_value_mask(value_mask)</code>","text":"<p>Sets the value mask of the base filter of store.</p> <p>Parameters:</p> <ul> <li> <code>value_mask</code>               (<code>TDatatypeMask</code>)           \u2013            <p>Datatype mask.</p> </li> </ul>"},{"location":"api/store/mixer/","title":"Mixer Store","text":""},{"location":"api/store/mixer/#kif_lib.store.MixerStore","title":"<code>MixerStore</code>","text":"<p>               Bases: <code>Store[TOptions]</code></p> <p>Mixer store.</p> <p>Parameters:</p> <ul> <li> <code>store_name</code>               (<code>str</code>)           \u2013            <p>Name of the store plugin to instantiate.</p> </li> <li> <code>sources</code>               (<code>Iterable[Store]</code>, default:                   <code>tuple()</code> )           \u2013            <p>Sources to mix.</p> </li> <li> <code>sync_flags</code>               (<code>TSyncFlags | None</code>, default:                   <code>None</code> )           \u2013            <p>Sync flags.</p> </li> </ul>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.default_sync_flags","title":"<code>default_sync_flags</code>  <code>property</code>","text":"<p>The default value for :attr:<code>MixerStore.sync_flags</code>.</p>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.sources","title":"<code>sources</code>  <code>property</code>","text":"<p>The mixed sources.</p>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.sync_flags","title":"<code>sync_flags</code>  <code>property</code> <code>writable</code>","text":"<p>The sync flags of mixer.</p>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.get_default_sync_flags","title":"<code>get_default_sync_flags()</code>","text":"<p>Gets the default value for :attr:<code>MixerStore.sync_flags</code>.</p> <p>Returns:</p> <ul> <li> <code>SyncFlags</code>           \u2013            <p>Default sync flags.</p> </li> </ul>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.get_sources","title":"<code>get_sources()</code>","text":"<p>Gets the mixed underlying sources.</p> <p>Returns:</p> <ul> <li> <code>Collection[Store]</code>           \u2013            <p>Mixed sources.</p> </li> </ul>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.get_sync_flags","title":"<code>get_sync_flags()</code>","text":"<p>Gets the sync flags of mixer.</p> <p>Returns:</p> <ul> <li> <code>SyncFlags</code>           \u2013            <p>Sync flags.</p> </li> </ul>"},{"location":"api/store/mixer/#kif_lib.store.MixerStore.set_sync_flags","title":"<code>set_sync_flags(sync_flags=None)</code>","text":"<p>Sets the sync flags of mixer.</p> <p>If <code>sync_flags</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>sync_flags</code>               (<code>TSyncFlags | None</code>, default:                   <code>None</code> )           \u2013            <p>Sync flags.</p> </li> </ul>"},{"location":"api/store/sparql/","title":"SPARQL Store","text":""},{"location":"api/store/sparql/#kif_lib.store.SPARQL_Store","title":"<code>SPARQL_Store</code>","text":"<p>               Bases: <code>MixerStore[TOptions]</code></p> <p>SPARQL store.</p> <p>Parameters:</p> <ul> <li> <code>store_name</code>               (<code>str</code>)           \u2013            <p>Name of the store plugin to instantiate.</p> </li> <li> <code>args</code>               (<code>Args</code>, default:                   <code>()</code> )           \u2013            <p>Input sources.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Input source format (file extension or media type).</p> </li> <li> <code>location</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Relative or absolute IRI of the input source.</p> </li> <li> <code>file</code>               (<code>BinaryIO | TextIO | None</code>, default:                   <code>None</code> )           \u2013            <p>File-like object to be used as input source.</p> </li> <li> <code>data</code>               (<code>bytes | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Data to be used as input source.</p> </li> <li> <code>graph</code>               (<code>TGraph | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF graph to used as input source.</p> </li> <li> <code>rdflib_graph</code>               (<code>Graph | None</code>, default:                   <code>None</code> )           \u2013            <p>RDFLib graph to be used as input source.</p> </li> <li> <code>skolemize</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to skolemize the resulting graph.</p> </li> <li> <code>mapping</code>               (<code>SPARQL_Mapping | None</code>, default:                   <code>None</code> )           \u2013            <p>SPARQL mapping.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Other keyword arguments.</p> </li> </ul>"},{"location":"api/store/sparql/#kif_lib.store.SPARQL_Store.default_skolemize","title":"<code>default_skolemize</code>  <code>property</code>","text":"<p>The default value for :attr:<code>SPARQL_Store.skolemize</code>.</p>"},{"location":"api/store/sparql/#kif_lib.store.SPARQL_Store.skolemize","title":"<code>skolemize</code>  <code>property</code> <code>writable</code>","text":"<p>The skolemize flag of SPARQL store.</p>"},{"location":"api/store/sparql/#kif_lib.store.SPARQL_Store.get_default_skolemize","title":"<code>get_default_skolemize()</code>","text":"<p>Gets the default value for :attr:<code>SPARQL_Store.skolemize</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Default skolemize flag.</p> </li> </ul>"},{"location":"api/store/sparql/#kif_lib.store.SPARQL_Store.get_skolemize","title":"<code>get_skolemize()</code>","text":"<p>Gets the skolemize flag of SPARQL store.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>skolemize flag.</p> </li> </ul>"},{"location":"api/store/sparql/#kif_lib.store.SPARQL_Store.set_skolemize","title":"<code>set_skolemize(skolemize=None)</code>","text":"<p>Sets the skolemize flag of SPARQL store.</p> <p>If <code>skolemize</code> is <code>None</code>, resets it to the default.</p> <p>Parameters:</p> <ul> <li> <code>skolemize</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>skolemize flag.</p> </li> </ul>"},{"location":"api/vocabulary/db/","title":"DBpedia","text":""},{"location":"api/vocabulary/db/#kif_lib.vocabulary.db","title":"<code>db</code>","text":"<p>The DBpedia vocabulary module.</p>"},{"location":"api/vocabulary/db/#kif_lib.vocabulary.db.oc","title":"<code>oc(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a DBpedia ontology item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/db/#kif_lib.vocabulary.db.op","title":"<code>op(name, label=None, aliases=None, description=None, range=None, inverse=None, context=None)</code>","text":"<p>Creates a DBpedia ontology property with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>range</code>               (<code>TDatatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype.</p> </li> <li> <code>inverse</code>               (<code>TProperty | None</code>, default:                   <code>None</code> )           \u2013            <p>Inverse property.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/vocabulary/db/#kif_lib.vocabulary.db.p","title":"<code>p(name, label=None, aliases=None, description=None, range=None, inverse=None, context=None)</code>","text":"<p>Creates a DBpedia property with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>range</code>               (<code>TDatatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype.</p> </li> <li> <code>inverse</code>               (<code>TProperty | None</code>, default:                   <code>None</code> )           \u2013            <p>Inverse property.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/vocabulary/db/#kif_lib.vocabulary.db.r","title":"<code>r(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a DBpedia resource item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/db/#kif_lib.vocabulary.db.reload","title":"<code>reload(force=True, context=None)</code>","text":"<p>Reloads the <code>db</code> module.</p> <p>Parameters:</p> <ul> <li> <code>force</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force reload.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul>"},{"location":"api/vocabulary/eu/","title":"European Data Portal","text":""},{"location":"api/vocabulary/eu/#kif_lib.vocabulary.eu","title":"<code>eu</code>","text":"<p>The European Data Portal vocabulary module.</p>"},{"location":"api/vocabulary/eu/#kif_lib.vocabulary.eu.dataset","title":"<code>dataset(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a Europa dataset item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/eu/#kif_lib.vocabulary.eu.reload","title":"<code>reload(force=True, context=None)</code>","text":"<p>Reloads the <code>eu</code> module.</p> <p>Parameters:</p> <ul> <li> <code>force</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force reload.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul>"},{"location":"api/vocabulary/eu/#kif_lib.vocabulary.eu.theme","title":"<code>theme(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a Europa theme item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/fg/","title":"FactGrid","text":""},{"location":"api/vocabulary/fg/#kif_lib.vocabulary.fg","title":"<code>fg</code>","text":"<p>The FactGrid vocabulary module.</p>"},{"location":"api/vocabulary/fg/#kif_lib.vocabulary.fg.P","title":"<code>P(name, label=None, aliases=None, description=None, range=None, inverse=None, context=None)</code>","text":"<p>Creates a FactGrid property with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>int | str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>range</code>               (<code>TDatatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype.</p> </li> <li> <code>inverse</code>               (<code>TProperty | None</code>, default:                   <code>None</code> )           \u2013            <p>Inverse property.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/vocabulary/fg/#kif_lib.vocabulary.fg.Q","title":"<code>Q(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a FactGrid item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>int | str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/fg/#kif_lib.vocabulary.fg.reload","title":"<code>reload(force=True, context=None)</code>","text":"<p>Reloads the <code>fg</code> module.</p> <p>Parameters:</p> <ul> <li> <code>force</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force reload.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul>"},{"location":"api/vocabulary/pc/","title":"PubChem","text":""},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc","title":"<code>pc</code>","text":"<p>The PubChem vocabulary module.</p>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.IUPAC_name","title":"<code>IUPAC_name = Property(CHEMINF.IUPAC_Name_generated_by_LexiChem, Text).register(label='IUPAC name', description='IUPAC Name generated by LexiChem')</code>  <code>module-attribute</code>","text":"<p>The IUPAC name property.</p>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.isotope_atom_count","title":"<code>isotope_atom_count = Property(CHEMINF.isotope_atom_count_generated_by_pubchem_software_library, Quantity).register(label='isotope atom count', description='isotope atom count generated by pubchem software library')</code>  <code>module-attribute</code>","text":"<p>The isotope atom cound property.</p>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.molecular_weight","title":"<code>molecular_weight = Property(CHEMINF.molecular_weight_calculated_by_the_pubchem_software_library, Quantity).register(label='molecular weight', description='molecular weight calculated by the pubchem software library')</code>  <code>module-attribute</code>","text":"<p>The molecular weight property.</p>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.CID","title":"<code>CID(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a PubChem compound item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>int | str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.patent","title":"<code>patent(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a PubChem patent item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.reload","title":"<code>reload(force=True, context=None)</code>","text":"<p>Reloads the <code>pc</code> module.</p> <p>Parameters:</p> <ul> <li> <code>force</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force reload.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul>"},{"location":"api/vocabulary/pc/#kif_lib.vocabulary.pc.source","title":"<code>source(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a PubChem source item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/up/","title":"UniProt","text":""},{"location":"api/vocabulary/up/#kif_lib.vocabulary.up","title":"<code>up</code>","text":"<p>The UniProt vocabulary module.</p>"},{"location":"api/vocabulary/up/#kif_lib.vocabulary.up.reload","title":"<code>reload(force=True, context=None)</code>","text":"<p>Reloads the <code>eu</code> module.</p> <p>Parameters:</p> <ul> <li> <code>force</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force reload.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul>"},{"location":"api/vocabulary/up/#kif_lib.vocabulary.up.taxonomy","title":"<code>taxonomy(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a UniProt taxonomy item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>int | str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/wd/","title":"Wikidata","text":""},{"location":"api/vocabulary/wd/#kif_lib.vocabulary.wd","title":"<code>wd</code>","text":"<p>The Wikidata vocabulary module.</p>"},{"location":"api/vocabulary/wd/#kif_lib.vocabulary.wd.L","title":"<code>L(name, lemma=None, category=None, language=None, context=None)</code>","text":"<p>Creates a Wikidata lexeme with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>lemma</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Lemma.</p> </li> <li> <code>category</code>               (<code>TItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Lexical category.</p> </li> <li> <code>language</code>               (<code>TItem | None</code>, default:                   <code>None</code> )           \u2013            <p>Language.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Lexeme</code>           \u2013            <p>Lexeme.</p> </li> </ul>"},{"location":"api/vocabulary/wd/#kif_lib.vocabulary.wd.P","title":"<code>P(name, label=None, aliases=None, description=None, range=None, inverse=None, context=None)</code>","text":"<p>Creates a Wikidata property with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>int | str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>range</code>               (<code>TDatatype | None</code>, default:                   <code>None</code> )           \u2013            <p>Datatype.</p> </li> <li> <code>inverse</code>               (<code>TProperty | None</code>, default:                   <code>None</code> )           \u2013            <p>Inverse property.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Property</code>           \u2013            <p>Property.</p> </li> </ul>"},{"location":"api/vocabulary/wd/#kif_lib.vocabulary.wd.Q","title":"<code>Q(name, label=None, aliases=None, description=None, context=None)</code>","text":"<p>Creates a Wikidata item with the given descriptors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>int | str</code>)           \u2013            <p>Name.</p> </li> <li> <code>label</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Label.</p> </li> <li> <code>aliases</code>               (<code>TTextSet | None</code>, default:                   <code>None</code> )           \u2013            <p>Aliases.</p> </li> <li> <code>description</code>               (<code>TText | None</code>, default:                   <code>None</code> )           \u2013            <p>Description.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul>"},{"location":"api/vocabulary/wd/#kif_lib.vocabulary.wd.reload","title":"<code>reload(install_resolver=True, install_schema=True, force=True, context=None)</code>","text":"<p>Reloads the <code>wd</code> module.</p> <p>Parameters:</p> <ul> <li> <code>force</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force reload.</p> </li> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>KIF context.</p> </li> </ul>"},{"location":"guides/async/","title":"Async","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"},{"location":"guides/cli/","title":"KIF CLI","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"},{"location":"guides/context/","title":"Context","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"},{"location":"guides/data_model/","title":"Data Model","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"},{"location":"guides/overview/","title":"Overview","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"},{"location":"guides/rdf/","title":"RDF","text":"<p>[\ud83d\udea7 Under construction \ud83d\udea7]</p>"}]}